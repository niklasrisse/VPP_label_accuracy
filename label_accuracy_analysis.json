{"project":{"9162":"ffmpeg","9109":"ffmpeg","13035":"qemu","22693":"qemu","10735":"qemu","23386":"qemu","25859":"ffmpeg","24896":"ffmpeg","6999":"ffmpeg","17280":"ffmpeg","14308":"ffmpeg","24292":"qemu","22065":"qemu","9231":"qemu","22034":"ffmpeg","18329":"qemu","10962":"ffmpeg","17885":"qemu","11070":"qemu","18624":"ffmpeg","15125":"ffmpeg","16767":"ffmpeg","11334":"qemu","17553":"qemu","12946":"qemu","21794":"qemu","12243":"qemu","9434":"qemu","1089":"qemu","14599":"ffmpeg","1736":"qemu","8431":"qemu","21925":"ffmpeg","6025":"qemu","24483":"qemu","18409":"qemu","7267":"qemu","2620":"qemu","13114":"qemu","22006":"qemu","21335":"qemu","369":"qemu","164":"qemu","7048":"ffmpeg","21007":"ffmpeg","13739":"qemu","20613":"ffmpeg","9509":"qemu","7521":"qemu","23786":"ffmpeg","21919":"ffmpeg","3824":"qemu","16933":"qemu","14366":"ffmpeg","16370":"ffmpeg","10801":"qemu","20600":"ffmpeg","17353":"ffmpeg","13429":"ffmpeg","4009":"ffmpeg","6543":"ffmpeg","13740":"ffmpeg","26100":"ffmpeg","19912":"ffmpeg","9934":"ffmpeg","26315":"qemu","7191":"qemu","13888":"ffmpeg","10773":"ffmpeg","25738":"ffmpeg","14639":"ffmpeg","25737":"ffmpeg","24655":"ffmpeg","24424":"ffmpeg","17932":"ffmpeg","26435":"ffmpeg","15115":"qemu","15999":"qemu","18175":"ffmpeg","21050":"ffmpeg","8130":"qemu","13311":"ffmpeg","5508":"qemu","4362":"qemu","2329":"qemu","4006":"qemu","1338":"ffmpeg","14814":"qemu","25602":"qemu","27148":"qemu","19908":"ffmpeg","22976":"ffmpeg","18640":"qemu","22955":"ffmpeg","17737":"ffmpeg","1937":"ffmpeg","2451":"qemu","21750":"ffmpeg","5630":"qemu","22801":"qemu"},"patch_commit_id":{"9162":"366ac22ea5a8bab63c7f46cdad2ddb2ff22cdbed","9109":"428098165de4c3edfe42c1b7f00627d287015863","13035":"b0d768c35e08d2057b63e8e77e7a513c447199fa","22693":"daa76aa416b1e18ab1fac650ff53d966d8f21f68","10735":"af01492755b82ccaf0d15014477b34ba3ea643fc","23386":"d470ad42acfc73c45d3e8ed5311a491160b4c100","25859":"feb13aed794a7f1a1f8395159e9b077351348a34","24896":"41abc9da50ba7a7b68bbbf6622475ce7a3c72e3f","6999":"560b10a6c3627cccf6735170d370cf9e3d38e805","17280":"435535e41159fbe7423a12078d684329a554776d","14308":"a82468514048fb87d9bf38689866bc3b9aaccd02","24292":"a77fd4bb2988c05953fdc9f1524085870ec1c939","22065":"b3a6a2e0417c78ec5491347eb85a7d125a5fefdc","9231":"8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a","22034":"1c495b0bf690995c45f79f4f19500921e14ec78a","18329":"a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf","10962":"27bcf55f459e038e81f09c17e72e6d44898b9015","17885":"da5361cc685c004d8bb4e7c5e7b3a52c7aca2c56","11070":"895b00f62a7e86724dc7352d67c7808d37366130","18624":"d1916d13e28b87f4b1b214231149e12e1d536b4b","15125":"d1a58afb95f68c5375b4a7556317d835108509ed","16767":"92e483f8ed70d88d4f64337f65bae212502735d4","11334":"cdeaf1f15909e2e8af38f45aea7cfa467a729c52","17553":"9217e26f43df4aab7deaea35b21caacc1f1f854b","12946":"068593deea6cc61b06243a33c7fcfadb1650b654","21794":"ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c","12243":"88be7b4be4aa17c88247e162bdd7577ea79db94f","9434":"7c24384b3b984f0256ba10eb26d877ec28985019","1089":"384b557da1a44ce260cd0328c06a250507348f73","14599":"290e7eb77bee5a54182fb3d5fb122c1e117190da","1736":"47d4be12c3997343e436c6cca89aefbbbeb70863","8431":"60fe637bf0e4d7989e21e50f52526444765c63b4","21925":"2c90316b46fce5785bc6af72c8fd369c31666604","6025":"ea375f9ab8c76686dca0af8cb4f87a4eb569cad3","24483":"240ce26a0533a6e5ee472789fbfbd9f7f939197e","18409":"e5d9adbdab972a2172815c1174aed3fabcc448f1","7267":"0479097859372a760843ad1b9c6ed3705c6423ca","2620":"b0706b716769494f321a0d2bfd9fa9893992f995","13114":"187337f8b0ec0813dd3876d1efe37d415fb81c2e","22006":"33bef0b9948b85000221d32c758d9d4a9276aaaf","21335":"07d4e69147b4957e617812206a62a86f03294ad3","369":"0b8b8753e4d94901627b3e86431230f2319215c4","164":"9bb234b3b170299c39c9e88cfe7da5434a92d99d","7048":"7117547298b13d6f52a20d6a62a27dc0a1c3e263","21007":"e30b068ef79f604ff439418da07f7e2efd01d4ea","13739":"b71706d122838d9656e1a6dae80e22401babdf37","20613":"2254b559cbcfc0418135f09add37c0a5866b1981","9509":"e3697092228770c3b23d0bf524e18b508b109932","7521":"03a63484a6978f68caff087bbaabcd1d383563af","23786":"8cd1c0febe88b757e915e9af15559575c21ca728","21919":"8000d484b83aafa752d84fbdbfb352ffe0dc64f8","3824":"6764579f894950afe87d8ec3b323adde8925d4fd","16933":"a9db86b223030bd40bdd81b160788196bc95fe6f","14366":"a6d6b8a20072a5919d38258dd48cc612e2372f81","16370":"e1fb3143bb3a6006612fe0e1d1a15c8eb4955802","10801":"d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0","20600":"6fd00e9dd94ac3aecf4fa14ca6fa23c395215ac9","17353":"eb9fb508b0e09d85d234fe694333b2005e1d7a7e","13429":"6abc56e892c2c2500d1fc2698fa6d580b72f721b","4009":"6f1b2967712e25e4c39c506862982b3011e06532","6543":"fdbc544d29176ba69d67dd879df4696f0a19052e","13740":"8d0a2180582005e91d9f14ae3dd219a882277c23","26100":"ac4b32df71bd932838043a4838b86d11e169707f","19912":"12dea8a5a15343e9c404376c40ca8a1cc9d1479e","9934":"2fed05f53a881b64a02de7a324d67d8c029c6cf1","26315":"0b8b8753e4d94901627b3e86431230f2319215c4","7191":"a890643958f03aaa344290700093b280cb606c28","13888":"374c907fb35f8236547b24d792fbb9bed201e321","10773":"d094052c8e8a036666ac02bfc52bf221ad39e4c8","25738":"74b1bf632f125a795e66e5fd0a060b9c7c55b7a3","14639":"d9051f8f3e60768f68867c3e3116e980d855215a","25737":"fbd6c97f9ca858140df16dd07200ea0d4bdc1a83","24655":"1bfb4587a2e5b25ed15f742149e555efc8f305ae","24424":"7167bc94cb695a3027aea6aac34a1b040848c7dc","17932":"cec939597722663f322941b4c12e00a583e63504","26435":"877f76ad33bb9b0b0d09565dd9ec1cf8e91096f1","15115":"4a1cba3802554a3b077d436002519ff1fb0c18bf","15999":"3010460fb99776bdf0a8b170555f2ab076382f9c","18175":"e5dd4ae7284bb290d8dc8e9cd3f2e035d1d77cd0","21050":"bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29","8130":"f7b879e072ae6839b1b1d1312f48fa7f256397e2","13311":"a52f443714b5c2a40ed272d8445f4c39220a4b69","5508":"660edd4eda903e32811a4929d1434cceda3284aa","4362":"e98768d43799cd3f00b358bfbe455fdae793d3e8","2329":"f8ed85ac992c48814d916d5df4d44f9a971c5de4","4006":"d3c8c67469ee70fcae116d5abc277a7ebc8a19fd'","1338":"1c495b0bf690995c45f79f4f19500921e14ec78a","14814":"7d1b0095bff7157e856d1d0e6c4295641ced2752","25602":"4f4321c11ff6e98583846bfd6f0e81954924b003","27148":"80e1eea37a25a7696137e680285e36d0bfdc9f34","19908":"984add64a41c3296a8a82051cc90bff2eb449609","22976":"8370e426e42f2e4b9d14a1fb8107ecfe5163ce7f","18640":"40545f84cfcbe4b73cca040b3043a1c2de935762","22955":"81cc7d0bd1eab0aa782ff8dd49e087025a42cdee","17737":"0232f788b6b0855db1771dbf8d7174e2eda2ff45","1937":"ec4c48397641dbaf4ae8df36c32aaa5a311a11bf","2451":"c1bf3531aecf4a0ba25bb150dd5fe21edf406c88","21750":"17269bdfcdb79679f6b92024d1228e876b799a63","5630":"6817efea3a0d1bf87be815970cdb014c5a64b628","22801":"bb44619b06c0bef20b658ff532cf850c16362ae7"},"label":{"9162":1,"9109":0,"13035":1,"22693":0,"10735":0,"23386":1,"25859":1,"24896":1,"6999":0,"17280":2,"14308":1,"24292":1,"22065":1,"9231":1,"22034":0,"18329":0,"10962":1,"17885":1,"11070":0,"18624":1,"15125":1,"16767":1,"11334":1,"17553":1,"12946":1,"21794":1,"12243":1,"9434":2,"1089":1,"14599":1,"1736":0,"8431":0,"21925":1,"6025":1,"24483":1,"18409":1,"7267":1,"2620":1,"13114":1,"22006":1,"21335":1,"369":0,"164":1,"7048":1,"21007":2,"13739":2,"20613":1,"9509":1,"7521":1,"23786":1,"21919":1,"3824":1,"16933":0,"14366":1,"16370":1,"10801":2,"20600":1,"17353":1,"13429":0,"4009":1,"6543":1,"13740":0,"26100":2,"19912":1,"9934":1,"26315":0,"7191":0,"13888":1,"10773":1,"25738":0,"14639":1,"25737":1,"24655":1,"24424":0,"17932":1,"26435":1,"15115":0,"15999":2,"18175":1,"21050":0,"8130":1,"13311":2,"5508":1,"4362":1,"2329":1,"4006":1,"1338":0,"14814":0,"25602":2,"27148":1,"19908":1,"22976":1,"18640":1,"22955":1,"17737":0,"1937":1,"2451":1,"21750":1,"5630":0,"22801":1},"type":{"9162":"Null Pointer Dereference","9109":null,"13035":"Crash \/ DoS","22693":null,"10735":null,"23386":"Null Pointer \/ Crash \/ DoS","25859":"Memory Leak","24896":"Null Pointer Dereference","6999":null,"17280":null,"14308":"OOM \/ DoS","24292":"Hang \/ DoS","22065":"Overflow","9231":null,"22034":null,"18329":null,"10962":"Memory Leak","17885":"Deadlock \/ Segfaul \/ DoS","11070":null,"18624":"Overflow","15125":"Out-of-bounds Write","16767":"Overflow","11334":"Memory Leak","17553":"Double Free","12946":"Out-of-bounds Write","21794":"Overflow","12243":"Memory Leak","9434":null,"1089":"Crash \/ DoS","14599":"Endless Loop \/ DoS","1736":null,"8431":null,"21925":"Memory Leak","6025":"races, segfaults and deadlocks","24483":"Error \/ DoS","18409":"Deadlock \/ DoS","7267":"Crash \/ DoS","2620":"Race Condition","13114":"Off-by-one \/ DoS","22006":"Off-by-one \/ DoS","21335":"Crash \/ DoS","369":null,"164":"Crash \/ DoS","7048":"Overread \/ Write","21007":null,"13739":null,"20613":"Overflow","9509":"Crash \/ DoS","7521":"Memory Leak","23786":"Input Buffer Overread","21919":"Overflow","3824":"Crash \/ DoS","16933":null,"14366":"Crash \/ DoS","16370":"Deadlock \/ DoS","10801":null,"20600":"Invalid Read","17353":"Overflow \/ Crash \/ DoS","13429":null,"4009":"Use of uninitialized memory","6543":"Memory Leak","13740":null,"26100":null,"19912":"Memory Leak","9934":"Overflow","26315":null,"7191":null,"13888":"Null Pointer Dereference","10773":"Crash \/ DoS","25738":null,"14639":"Runtime Error \/ Crash \/ DoS","25737":"Memory Leak","24655":"Memory Leak","24424":null,"17932":"Overfflow","26435":"Use of uninitalized memory","15115":null,"15999":null,"18175":"Null Pointer Dereference","21050":null,"8130":"Crash \/ DoS","13311":null,"5508":"Memory Leak","4362":"Overflow","2329":"Crash \/ DoS","4006":"Crash \/ DoS","1338":null,"14814":null,"25602":null,"27148":"Memory Leak","19908":"Overflow","22976":"Memory Leak","18640":null,"22955":"Overflow","17737":null,"1937":"Cross Origin Attack","2451":"Use after free","21750":"Double Free","5630":null,"22801":"Use-after-free"},"vulnerable_func":{"9162":"static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,\n                          IVITile *tile, AVCodecContext *avctx)\n{\n    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,\n                mv_scale, blks_per_mb;\n    IVIMbInfo   *mb, *ref_mb;\n    int         row_offset = band->mb_size * band->pitch;\n    mb     = tile->mbs;\n    ref_mb = tile->ref_mbs;\n    offs   = tile->ypos * band->pitch + tile->xpos;\n    \n    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);\n    mv_x = mv_y = 0;\n    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {\n        mb_offset = offs;\n        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {\n            mb->xpos     = x;\n            mb->ypos     = y;\n            mb->buf_offs = mb_offset;\n            if (get_bits1(&ctx->gb)) {\n                if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    av_log(avctx, AV_LOG_ERROR, \"Empty macroblock in an INTRA picture!\\n\");\n                    return -1;\n                }\n                mb->type = 1; \n                mb->cbp  = 0; \n                mb->q_delta = 0;\n                if (!band->plane && !band->band_num && (ctx->frame_flags & 8)) {\n                    mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                           IVI_VLC_BITS, 1);\n                    mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                }\n                mb->mv_x = mb->mv_y = 0; \n                if (band->inherit_mv){\n                    \n                    if (mv_scale) {\n                        mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                        mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                    } else {\n                        mb->mv_x = ref_mb->mv_x;\n                        mb->mv_y = ref_mb->mv_y;\n                    }\n                }\n            } else {\n                if (band->inherit_mv) {\n                    mb->type = ref_mb->type; \n                } else if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    mb->type = 0; \n                } else {\n                    mb->type = get_bits1(&ctx->gb);\n                }\n                blks_per_mb = band->mb_size != band->blk_size ? 4 : 1;\n                mb->cbp = get_bits(&ctx->gb, blks_per_mb);\n                mb->q_delta = 0;\n                if (band->qdelta_present) {\n                    if (band->inherit_qdelta) {\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n                                           (ctx->frame_flags & 8))) {\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                               IVI_VLC_BITS, 1);\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                    }\n                }\n                if (!mb->type) {\n                    mb->mv_x = mb->mv_y = 0; \n                } else {\n                    if (band->inherit_mv){\n                        \n                        if (mv_scale) {\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                        } else {\n                            mb->mv_x = ref_mb->mv_x;\n                            mb->mv_y = ref_mb->mv_y;\n                        }\n                    } else {\n                        \n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_y += IVI_TOSIGNED(mv_delta);\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_x += IVI_TOSIGNED(mv_delta);\n                        mb->mv_x = mv_x;\n                        mb->mv_y = mv_y;\n                    }\n                }\n            }\n            mb++;\n            if (ref_mb)\n                ref_mb++;\n            mb_offset += band->mb_size;\n        }\n        offs += row_offset;\n    }\n    align_get_bits(&ctx->gb);\n    return 0;\n}","9109":"static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n    int y, h_size;\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\tsrcStride[1] *= 2;\n\tsrcStride[2] *= 2;\n    }\n    h_size= (c->dstW+7)&~7;\n    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\"  );\n    for (y= 0; y<srcSliceH; y++ ) {\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\tlong index= -h_size\/2;\n\tb5Dither= dither8[y&1];\n\tg6Dither= dither4[y&1];\n\tg5Dither= dither8[y&1];\n\tr5Dither= dither8[(y+1)&1];\n\t    \n\t    __asm__ __volatile__ (\n\t\n\t\t     \"movd (%2, %0), %%mm0;\" \n\t\t     \"movd (%3, %0), %%mm1;\" \n\t\t     \"movq (%5, %0, 2), %%mm6;\" \n\t\t    \"1:\t\t\t\t\\n\\t\"\nYUV2RGB\n#ifdef DITHER1XBPP\n\t\t\t\"paddusb \"MANGLE(b5Dither)\", %%mm0;\"\n\t\t\t\"paddusb \"MANGLE(g6Dither)\", %%mm2;\"\n\t\t\t\"paddusb \"MANGLE(r5Dither)\", %%mm1;\"\n#endif\n\t\t     \n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm0;\" \n\t\t     \"pand \"MANGLE(mmx_grnmask)\", %%mm2;\" \n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm1;\" \n\t\t     \"psrlw $3,%%mm0;\" \n\t\t     \"pxor %%mm4, %%mm4;\" \n\t\t     \"movq %%mm0, %%mm5;\" \n\t\t     \"movq %%mm2, %%mm7;\" \n\t\t     \n\t\t     \"punpcklbw %%mm4, %%mm2;\" \n\t\t     \"punpcklbw %%mm1, %%mm0;\" \n\t\t     \"psllw $3, %%mm2;\" \n\t\t     \"por %%mm2, %%mm0;\" \n\t\t     \"movq 8 (%5, %0, 2), %%mm6;\" \n\t\t     MOVNTQ \" %%mm0, (%1);\" \n\t\t     \n\t\t     \"punpckhbw %%mm4, %%mm7;\" \n\t\t     \"punpckhbw %%mm1, %%mm5;\" \n\t\t     \"psllw $3, %%mm7;\" \n\t\t     \"movd 4 (%2, %0), %%mm0;\" \n\t\t     \"por %%mm7, %%mm5;\" \n\t\t     \"movd 4 (%3, %0), %%mm1;\" \n\t\t     MOVNTQ \" %%mm5, 8 (%1);\" \n\t\t     \"add $16, %1\t\t\t\\n\\t\"\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\t\t     );\n    }\n    __asm__ __volatile__ (EMMS);\n    return srcSliceH;\n}","13035":"static gboolean pty_chr_timer(gpointer opaque)\n{\n    struct CharDriverState *chr = opaque;\n    PtyCharDriver *s = chr->opaque;\n    if (s->connected) {\n        goto out;\n    }\n    \n    pty_chr_update_read_handler(chr);\nout:\n    s->timer_tag = 0;\n    return FALSE;\n}","22693":"void trace_init_file(const char *file)\n{\n#ifdef CONFIG_TRACE_SIMPLE\n    st_set_trace_file(file);\n#elif defined CONFIG_TRACE_LOG\n    \n    if (file) {\n        qemu_set_log_filename(file);\n    }\n#else\n    if (file) {\n        fprintf(stderr, \"error: -trace file=...: \"\n                \"option not supported by the selected tracing backends\\n\");\n        exit(1);\n    }\n#endif\n}","10735":"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n{\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n    usb_desc_create_serial(dev);\n    usb_desc_init(dev);\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n                 &usb_msd_scsi_info_bot, NULL);\n    s->bus.qbus.allow_hotplug = 0;\n    usb_msd_handle_reset(dev);\n}","23386":"static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        \n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                \n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;","25859":"static int filter_frame(AVFilterLink *inlink, AVFrame *picref)\n{\n    AVFilterContext *ctx = inlink->dst;\n    SignatureContext *sic = ctx->priv;\n    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);\n    FineSignature* fs;\n    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };\n    \n    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};\n    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};\n    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; \n    uint64_t intpic[32][32];\n    uint64_t rowcount;\n    uint8_t *p = picref->data[0];\n    int inti, intj;\n    int *intjlut;\n    uint64_t conflist[DIFFELEM_SIZE];\n    int f = 0, g = 0, w = 0;\n    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;\n    int64_t denom;\n    int i, j, k, ternary;\n    uint64_t blocksum;\n    int blocksize;\n    int64_t th; \n    int64_t sum;\n    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;\n    \n    if (sc->curfinesig) {\n        fs = av_mallocz(sizeof(FineSignature));\n        if (!fs)\n            return AVERROR(ENOMEM);\n        sc->curfinesig->next = fs;\n        fs->prev = sc->curfinesig;\n        sc->curfinesig = fs;\n    } else {\n        fs = sc->curfinesig = sc->finesiglist;\n        sc->curcoarsesig1->first = fs;\n    }\n    fs->pts = picref->pts;\n    fs->index = sc->lastindex++;\n    memset(intpic, 0, sizeof(uint64_t)*32*32);\n    intjlut = av_malloc_array(inlink->w, sizeof(int));\n    if (!intjlut)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < inlink->w; i++) {\n        intjlut[i] = (i*32)\/inlink->w;\n    }\n    for (i = 0; i < inlink->h; i++) {\n        inti = (i*32)\/inlink->h;\n        for (j = 0; j < inlink->w; j++) {\n            intj = intjlut[j];\n            intpic[inti][intj] += p[j];\n        }\n        p += picref->linesize[0];\n    }\n    av_freep(&intjlut);\n    \n    dh1 = inlink->h \/ 32;\n    if (inlink->h % 32)\n        dh2 = dh1 + 1;\n    dw1 = inlink->w \/ 32;\n    if (inlink->w % 32)\n        dw2 = dw1 + 1;\n    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;\n    for (i = 0; i < 32; i++) {\n        rowcount = 0;\n        a = 1;\n        if (dh2 > 1) {\n            a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))\/32 - 1 : (inlink->h*(i+1))\/32;\n            a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)\/32 - 1 : (inlink->h*i)\/32;\n            a = (a == dh1)? dh2 : dh1;\n        }\n        for (j = 0; j < 32; j++) {\n            b = 1;\n            if (dw2 > 1) {\n                b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))\/32 - 1 : (inlink->w*(j+1))\/32;\n                b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)\/32 - 1 : (inlink->w*j)\/32;\n                b = (b == dw1)? dw2 : dw1;\n            }\n            rowcount += intpic[i][j] * a * b * precfactor \/ denom;\n            if (i > 0) {\n                intpic[i][j] = intpic[i-1][j] + rowcount;\n            } else {\n                intpic[i][j] = rowcount;\n            }\n        }\n    }\n    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;\n    for (i = 0; i < ELEMENT_COUNT; i++) {\n        const ElemCat* elemcat = elements[i];\n        int64_t* elemsignature;\n        uint64_t* sortsignature;\n        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n        if (!elemsignature)\n            return AVERROR(ENOMEM);\n        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n        if (!sortsignature)\n            return AVERROR(ENOMEM);\n        for (j = 0; j < elemcat->elem_count; j++) {\n            blocksum = 0;\n            blocksize = 0;\n            for (k = 0; k < elemcat->left_count; k++) {\n                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n            }\n            sum = blocksum \/ blocksize;\n            if (elemcat->av_elem) {\n                sum -= 128 * precfactor * denom;\n            } else {\n                blocksum = 0;\n                blocksize = 0;\n                for (; k < elemcat->block_count; k++) {\n                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n                }\n                sum -= blocksum \/ blocksize;\n                conflist[g++] = FFABS(sum * 8 \/ (precfactor * denom));\n            }\n            elemsignature[j] = sum;\n            sortsignature[j] = FFABS(sum);\n        }\n        \n        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);\n        th = sortsignature[(int) (elemcat->elem_count*0.333)];\n        \n        for (j = 0; j < elemcat->elem_count; j++) {\n            if (elemsignature[j] < -th) {\n                ternary = 0;\n            } else if (elemsignature[j] <= th) {\n                ternary = 1;\n            } else {\n                ternary = 2;\n            }\n            fs->framesig[f\/5] += ternary * pot3[f%5];\n            if (f == wordvec[w]) {\n                fs->words[s2usw[w]\/5] += ternary * pot3[wordt2b[s2usw[w]\/5]++];\n                if (w < 24)\n                    w++;\n            }\n            f++;\n        }\n        av_freep(&elemsignature);\n        av_freep(&sortsignature);\n    }\n    \n    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);\n    fs->confidence = FFMIN(conflist[DIFFELEM_SIZE\/2], 255);\n    \n    if (sc->coarsecount == 0) {\n        if (sc->curcoarsesig2) {\n            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));\n            if (!sc->curcoarsesig1)\n                return AVERROR(ENOMEM);\n            sc->curcoarsesig1->first = fs;\n            sc->curcoarsesig2->next = sc->curcoarsesig1;\n            sc->coarseend = sc->curcoarsesig1;\n        }\n    }\n    if (sc->coarsecount == 45) {\n        sc->midcoarse = 1;\n        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));\n        if (!sc->curcoarsesig2)\n            return AVERROR(ENOMEM);\n        sc->curcoarsesig2->first = fs;\n        sc->curcoarsesig1->next = sc->curcoarsesig2;\n        sc->coarseend = sc->curcoarsesig2;\n    }\n    for (i = 0; i < 5; i++) {\n        set_bit(sc->curcoarsesig1->data[i], fs->words[i]);\n    }\n    \n    sc->curcoarsesig1->last = fs;\n    if (sc->midcoarse) {\n        for (i = 0; i < 5; i++) {\n            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);\n        }\n        sc->curcoarsesig2->last = fs;\n    }\n    sc->coarsecount = (sc->coarsecount+1)%90;\n    \n    if (av_log_get_level() == AV_LOG_DEBUG) {\n        av_log(ctx, AV_LOG_DEBUG, \"input %d, confidence: %d\\n\", FF_INLINK_IDX(inlink), fs->confidence);\n        av_log(ctx, AV_LOG_DEBUG, \"words:\");\n        for (i = 0; i < 5; i++) {\n            av_log(ctx, AV_LOG_DEBUG, \" %d:\", fs->words[i] );\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->words[i] \/ pot3[0] );\n            for (j = 1; j < 5; j++)\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->words[i] % pot3[j-1] \/ pot3[j] );\n            av_log(ctx, AV_LOG_DEBUG, \";\");\n        }\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n        av_log(ctx, AV_LOG_DEBUG, \"framesignature:\");\n        for (i = 0; i < SIGELEM_SIZE\/5; i++) {\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->framesig[i] \/ pot3[0] );\n            for (j = 1; j < 5; j++)\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->framesig[i] % pot3[j-1] \/ pot3[j] );\n        }\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n    }\n    if (FF_INLINK_IDX(inlink) == 0)\n        return ff_filter_frame(inlink->dst->outputs[0], picref);\n    return 1;\n}","24896":"static int decode_frame_ilbm(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    IffContext *s = avctx->priv_data;\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n    const uint8_t *buf_end = buf+buf_size;\n    int y, plane, res;\n    if ((res = extract_header(avctx, avpkt)) < 0)\n        return res;\n    if (s->init) {\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n            return res;\n        }\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return res;\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n            return res;\n    }\n    s->init = 1;\n    if (avctx->codec_tag == MKTAG('A','C','B','M')) {\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n            for (plane = 0; plane < s->bpp; plane++) {\n                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n                    buf += s->planesize;\n                }\n            }\n        } else if (s->ham) { \n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n            for(y = 0; y < avctx->height; y++) {\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n                memset(s->ham_buf, 0, s->planesize * 8);\n                for (plane = 0; plane < s->bpp; plane++) {\n                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;\n                    if (start >= buf_end)\n                        break;\n                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n                }\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n            }\n        }\n    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {\n        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);\n        int x;\n        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n            buf += raw_width;\n            if (avctx->pix_fmt == PIX_FMT_BGR32) {\n                for(x = 0; x < avctx->width; x++)\n                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n            }\n        }\n    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { \n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n            for(y = 0; y < avctx->height; y++ ) {\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n                memset(row, 0, avctx->width);\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n                    buf += s->planesize;\n                }\n            }\n        } else if (s->ham) { \n            for (y = 0; y < avctx->height; y++) {\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n                memset(s->ham_buf, 0, s->planesize * 8);\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n                    buf += s->planesize;\n                }\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n            }\n        } else { \n            for(y = 0; y < avctx->height; y++ ) {\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n                memset(row, 0, avctx->width << 2);\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n                    buf += s->planesize;\n                }\n            }\n        }\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { \n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n            for(y = 0; y < avctx->height; y++ ) {\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n                buf += avctx->width + (avctx->width % 2); \n            }\n        } else if (s->ham) { \n            for (y = 0; y < avctx->height; y++) {\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n                buf += avctx->width + (avctx->width & 1); \n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n            }\n        } else {\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    *data_size = sizeof(AVFrame);\n    *(AVFrame*)data = s->frame;\n    return buf_size;\n}","6999":"static void init_gain_table(COOKContext *q) {\n    int i;\n    q->gain_size_factor = q->samples_per_channel\/8;\n    for (i=0 ; i<23 ; i++) {\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n                               (1.0\/(double)q->gain_size_factor));\n    }\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n}","17280":"static int read_header(AVFormatContext *s,\n                       AVFormatParameters *ap)\n{\n    JVDemuxContext *jv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *vst, *ast;\n    int64_t audio_pts = 0;\n    int64_t offset;\n    int i;\n    avio_skip(pb, 80);\n    ast = av_new_stream(s, 0);\n    vst = av_new_stream(s, 1);\n    if (!ast || !vst)\n        return AVERROR(ENOMEM);\n    vst->codec->codec_type  = CODEC_TYPE_VIDEO;\n    vst->codec->codec_id    = CODEC_ID_JV;\n    vst->codec->codec_tag   = 0; \n    vst->codec->width       = avio_rl16(pb);\n    vst->codec->height      = avio_rl16(pb);\n    vst->nb_frames          =\n    ast->nb_index_entries   = avio_rl16(pb);\n    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);\n    avio_skip(pb, 4);\n    ast->codec->codec_type  = CODEC_TYPE_AUDIO;\n    ast->codec->codec_id    = CODEC_ID_PCM_U8;\n    ast->codec->codec_tag   = 0; \n    ast->codec->sample_rate = avio_rl16(pb);\n    ast->codec->channels    = 1;\n    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);\n    avio_skip(pb, 10);\n    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));\n    if (!ast->index_entries)\n        return AVERROR(ENOMEM);\n    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));\n    if (!jv->frames)\n        return AVERROR(ENOMEM);\n    offset = 0x68 + ast->nb_index_entries * 16;\n    for(i = 0; i < ast->nb_index_entries; i++) {\n        AVIndexEntry *e   = ast->index_entries + i;\n        JVFrame      *jvf = jv->frames + i;\n        \n        e->size         = avio_rl32(pb);\n        e->timestamp    = i;\n        e->pos          = offset;\n        offset         += e->size;\n        jvf->audio_size = avio_rl32(pb);\n        jvf->video_size = avio_rl32(pb);\n        jvf->palette_size = avio_r8(pb) ? 768 : 0;\n        if (avio_r8(pb))\n             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");\n        jvf->video_type = avio_r8(pb);\n        avio_skip(pb, 1);\n        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;\n        audio_pts += jvf->audio_size;\n        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;\n    }\n    jv->state = JV_AUDIO;\n    return 0;\n}","14308":"av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n                               int is_indeo4)\n{\n    int p, b;\n    uint32_t b_width, b_height, align_fac, width_aligned,\n             height_aligned, buf_size;\n    IVIBandDesc *band;\n    ivi_free_buffers(planes);\n    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n        return AVERROR_INVALIDDATA;\n    \n    planes[0].width     = cfg->pic_width;\n    planes[0].height    = cfg->pic_height;\n    planes[0].num_bands = cfg->luma_bands;\n    \n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n    for (p = 0; p < 3; p++) {\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n        if (!planes[p].bands)\n            return AVERROR(ENOMEM);\n        \n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n                                            : (planes[p].width  + 1) >> 1;\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n                                            : (planes[p].height + 1) >> 1;\n        \n        \n        align_fac       = p ? 8 : 16;\n        width_aligned   = FFALIGN(b_width , align_fac);\n        height_aligned  = FFALIGN(b_height, align_fac);\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n        for (b = 0; b < planes[p].num_bands; b++) {\n            band = &planes[p].bands[b]; \n            band->plane    = p;\n            band->band_num = b;\n            band->width    = b_width;\n            band->height   = b_height;\n            band->pitch    = width_aligned;\n            band->aheight  = height_aligned;\n            band->bufs[0]  = av_mallocz(buf_size);\n            band->bufs[1]  = av_mallocz(buf_size);\n            band->bufsize  = buf_size\/2;\n            if (!band->bufs[0] || !band->bufs[1])\n                return AVERROR(ENOMEM);\n            \n            if (cfg->luma_bands > 1) {\n                band->bufs[2] = av_mallocz(buf_size);\n                if (!band->bufs[2])\n                    return AVERROR(ENOMEM);\n            }\n            if (is_indeo4) {\n                band->bufs[3]  = av_mallocz(buf_size);\n                if (!band->bufs[3])\n                    return AVERROR(ENOMEM);\n            }\n            \n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n        }\n    }\n    return 0;\n}","24292":"void bdrv_drain(BlockDriverState *bs)\n{\n    bool busy = true;\n    bdrv_drain_recurse(bs);\n    while (busy) {\n        \n         bdrv_flush_io_queue(bs);\n         busy = bdrv_requests_pending(bs);\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n","22065":"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n{\n    flag aSign;\n    int16 aExp, shiftCount;\n    uint64_t aSig, savedASig;\n    int32 z;\n    a = float64_squash_input_denormal(a STATUS_VAR);\n    aSig = extractFloat64Frac( a );\n    aExp = extractFloat64Exp( a );\n    aSign = extractFloat64Sign( a );\n    if ( 0x41E < aExp ) {\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n        goto invalid;\n    }\n    else if ( aExp < 0x3FF ) {\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n        return 0;\n    }\n    aSig |= LIT64( 0x0010000000000000 );\n    shiftCount = 0x433 - aExp;\n    savedASig = aSig;\n    aSig >>= shiftCount;\n    z = aSig;\n    if ( aSign ) z = - z;\n    if ( ( z < 0 ) ^ aSign ) {\n invalid:\n        float_raise( float_flag_invalid STATUS_VAR);\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n    }\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n        STATUS(float_exception_flags) |= float_flag_inexact;\n    }\n    return z;\n}","9231":"void object_property_allow_set_link(Object *obj, const char *name,\n                                    Object *val, Error **errp)\n{\n    \n}","22034":"static void dwt_encode97_int(DWTContext *s, int *t)\n{\n    int lev,\n        w = s->linelen[s->ndeclevels-1][0];\n    int *line = s->i_linebuf;\n    line += 5;\n    for (lev = s->ndeclevels-1; lev >= 0; lev--){\n        int lh = s->linelen[lev][0],\n            lv = s->linelen[lev][1],\n            mh = s->mod[lev][0],\n            mv = s->mod[lev][1],\n            lp;\n        int *l;\n        \n        l = line + mv;\n        for (lp = 0; lp < lh; lp++) {\n            int i, j = 0;\n            for (i = 0; i < lv; i++)\n                l[i] = t[w*i + lp];\n            sd_1d97_int(line, mv, mv + lv);\n            \n            for (i =   mv; i < lv; i+=2, j++)\n                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n            for (i = 1-mv; i < lv; i+=2, j++)\n                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n        }\n        \n        l = line + mh;\n        for (lp = 0; lp < lv; lp++){\n            int i, j = 0;\n            for (i = 0; i < lh; i++)\n                l[i] = t[w*lp + i];\n            sd_1d97_int(line, mh, mh + lh);\n            \n            for (i =   mh; i < lh; i+=2, j++)\n                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n            for (i = 1-mh; i < lh; i+=2, j++)\n                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n        }\n    }\n}","18329":"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n                                    Error **errp)\n{\n    QObjectInputVisitor *qiv = to_qiv(v);\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n    QBool *qbool;\n    if (!qobj) {\n        return;\n    }\n    qbool = qobject_to_qbool(qobj);\n    if (!qbool) {\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n                   \"boolean\");\n        return;\n    }\n    *obj = qbool_get_bool(qbool);\n}","10962":"int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref)\n{\n    BufferSourceContext *c = buffer_filter->priv;\n    AVFilterLink *outlink = buffer_filter->outputs[0];\n    int ret;\n    if (c->picref) {\n        av_log(buffer_filter, AV_LOG_ERROR,\n               \"Buffering several frames is not supported. \"\n               \"Please consume all available frames before adding a new one.\\n\"\n            );\n        \n    }\n    if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n        AVFilterContext *scale = buffer_filter->outputs[0]->dst;\n        AVFilterLink *link;\n        char scale_param[1024];\n        av_log(buffer_filter, AV_LOG_INFO,\n               \"Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n               c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name,\n               picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name);\n        if (!scale || strcmp(scale->filter->name, \"scale\")) {\n            AVFilter *f = avfilter_get_by_name(\"scale\");\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n            if ((ret = avfilter_open(&scale, f, \"Input equalizer\")) < 0)\n                return ret;\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\", c->w, c->h, c->sws_param);\n            if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) {\n                avfilter_free(scale);\n                return ret;\n            }\n            if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) {\n                avfilter_free(scale);\n                return ret;\n            }\n            scale->outputs[0]->time_base = scale->inputs[0]->time_base;\n            scale->outputs[0]->format= c->pix_fmt;\n        } else if (!strcmp(scale->filter->name, \"scale\")) {\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\",\n                     scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n            scale->filter->init(scale, scale_param, NULL);\n        }\n        c->pix_fmt = scale->inputs[0]->format = picref->format;\n        c->w       = scale->inputs[0]->w      = picref->video->w;\n        c->h       = scale->inputs[0]->h      = picref->video->h;\n        link = scale->outputs[0];\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n            return ret;\n    }\n    c->picref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,\n                                          picref->video->w, picref->video->h);\n    av_image_copy(c->picref->data, c->picref->linesize,\n                  picref->data, picref->linesize,\n                  picref->format, picref->video->w, picref->video->h);\n    avfilter_copy_buffer_ref_props(c->picref, picref);\n    return 0;\n}","17885":"static int emulated_exitfn(CCIDCardState *base)\n{\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n    vevent_queue_vevent(vevent); \n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n    card->quit_apdu_thread = 1; \n    qemu_cond_signal(&card->handle_apdu_cond);\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n                      &card->apdu_thread_quit_mutex);\n    \n    qemu_cond_destroy(&card->handle_apdu_cond);\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n    qemu_mutex_destroy(&card->vreader_mutex);\n    qemu_mutex_destroy(&card->event_list_mutex);\n    return 0;\n}","11070":"void qmp_guest_file_flush(int64_t handle, Error **errp)\n{\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    FILE *fh;\n    int ret;\n    if (!gfh) {\n        return;\n    }\n    fh = gfh->fh;\n    ret = fflush(fh);\n    if (ret == EOF) {\n        error_setg_errno(errp, errno, \"failed to flush file\");\n    }\n}","18624":"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}","15125":"static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    AVIOContext *pb = s->pb;\n    PutBitContext bs;\n    int i, len;\n    uint8_t loas_header[] = \"\\x56\\xe0\\x00\";\n    uint8_t *buf = NULL;\n    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)\n        return ff_raw_write_packet(s, pkt);\n    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {\n        av_log(s, AV_LOG_ERROR, \"ADTS header detected - ADTS will not be incorrectly muxed into LATM\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (pkt->size > 0x1fff)\n        goto too_large;\n    buf = av_malloc(pkt->size+1024);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    init_put_bits(&bs, buf, pkt->size+1024);\n    latm_write_frame_header(s, &bs);\n    \n    for (i = 0; i <= pkt->size-255; i+=255)\n        put_bits(&bs, 8, 255);\n    put_bits(&bs, 8, pkt->size-i);\n    \n    \n    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {\n        \n        \n        \n        \n        \n        \n        \n        \n        put_bits(&bs, 8, pkt->data[0] & 0xfe);\n        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);\n    } else\n        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);\n    avpriv_align_put_bits(&bs);\n    flush_put_bits(&bs);\n    len = put_bits_count(&bs) >> 3;\n    if (len > 0x1fff)\n        goto too_large;\n    loas_header[1] |= (len >> 8) & 0x1f;\n    loas_header[2] |= len & 0xff;\n    avio_write(pb, loas_header, 3);\n    avio_write(pb, buf, len);\n    av_free(buf);\n    return 0;\ntoo_large:\n    av_log(s, AV_LOG_ERROR, \"LATM packet size larger than maximum size 0x1fff\\n\");\n    av_free(buf);\n    return AVERROR_INVALIDDATA;\n}","16767":"static int compare_int64(const void *a, const void *b)\n{\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n    return va < vb ? -1 : va > vb ? +1 : 0;\n}","11334":"static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n                                      const uint8_t *buf, int nb_sectors)\n{\n    int ret;\n    BDRVVmdkState *s = bs->opaque;\n    qemu_co_mutex_lock(&s->lock);\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}","17553":"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\tconst uint8_t* buffer, int nb_sectors) {\n    BDRVVVFATState* s = bs->opaque;\n    return try_commit(s);\n}","12946":"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n{\n    int i = 0;\n    int x = 0;\n    uint32_t l_64 = (l + 1) \/ 8;\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n               __func__, l, dest, src);\n#ifndef CONFIG_USER_ONLY\n    if ((l > 32) &&\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n        if (dest == (src + 1)) {\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n            return;\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n            mvc_fast_memmove(env, l + 1, dest, src);\n            return;\n        }\n    }\n#else\n    if (dest == (src + 1)) {\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n        return;\n    } else {\n        memmove(g2h(dest), g2h(src), l + 1);\n        return;\n    }\n#endif\n    \n    if (dest != (src + 1)) {\n        for (i = 0; i < l_64; i++) {\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n            x += 8;\n        }\n    }\n    \n    for (i = x; i <= l; i++) {\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n    }\n}","21794":"static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n{\n    HWPoisonPage *page;\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n        if (page->ram_addr == ram_addr) {\n            return;\n        }\n    }\n    page = g_malloc(sizeof(HWPoisonPage));\n    page->ram_addr = ram_addr;\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n}","12243":"bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n{\n    BlockDriverState *bs;\n    BdrvNextIterator *it = NULL;\n    \n    while ((it = bdrv_next(it, &bs)) != NULL) {\n        bool perm;\n        \n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n        \n        if (perm) {\n            return true;\n        }\n    }\n    return false;\n}","9434":"static int64_t nfs_client_open(NFSClient *client, const char *filename,\n                               int flags, Error **errp)\n{\n    int ret = -EINVAL, i;\n    struct stat st;\n    URI *uri;\n    QueryParams *qp = NULL;\n    char *file = NULL, *strp = NULL;\n    uri = uri_parse(filename);\n    if (!uri) {\n        error_setg(errp, \"Invalid URL specified\");\n        goto fail;\n    }\n    if (!uri->server) {\n        error_setg(errp, \"Invalid URL specified\");\n        goto fail;\n    }\n    strp = strrchr(uri->path, '\/');\n    if (strp == NULL) {\n        error_setg(errp, \"Invalid URL specified\");\n        goto fail;\n    }\n    file = g_strdup(strp);\n    *strp = 0;\n    client->context = nfs_init_context();\n    if (client->context == NULL) {\n        error_setg(errp, \"Failed to init NFS context\");\n        goto fail;\n    }\n    qp = query_params_parse(uri->query);\n    for (i = 0; i < qp->n; i++) {\n        if (!qp->p[i].value) {\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n                       qp->p[i].name);\n            goto fail;\n        }\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n        } else {\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n                       qp->p[i].name);\n            goto fail;\n        }\n    }\n    ret = nfs_mount(client->context, uri->server, uri->path);\n    if (ret < 0) {\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n                   nfs_get_error(client->context));\n        goto fail;\n    }\n    if (flags & O_CREAT) {\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n        if (ret < 0) {\n            error_setg(errp, \"Failed to create file: %s\",\n                       nfs_get_error(client->context));\n            goto fail;\n        }\n    } else {\n        ret = nfs_open(client->context, file, flags, &client->fh);\n        if (ret < 0) {\n            error_setg(errp, \"Failed to open file : %s\",\n                       nfs_get_error(client->context));\n            goto fail;\n        }\n    }\n    ret = nfs_fstat(client->context, client->fh, &st);\n    if (ret < 0) {\n        error_setg(errp, \"Failed to fstat file: %s\",\n                   nfs_get_error(client->context));\n        goto fail;\n    }\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n    client->has_zero_init = S_ISREG(st.st_mode);\n    goto out;\nfail:\n    nfs_client_close(client);\nout:\n    if (qp) {\n        query_params_free(qp);\n    }\n    uri_free(uri);\n    g_free(file);\n    return ret;\n}","1089":"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n                                                 uint64_t iova, uint64_t len)\n{\n    struct vhost_iotlb_msg imsg;\n    imsg.iova = iova;\n    imsg.size = len;\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n}","14599":"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n{\n    int i;\n    for (i=0; i < in->n; i++) {\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n        do {\n            out[x] = 0.0;\n            x += in->pitch_lag;\n        } while (x < size && repeats);\n    }\n}","1736":"static void test_qemu_strtoll_whitespace(void)\n{\n    const char *str = \"  \\t  \";\n    char f = 'X';\n    const char *endptr = &f;\n    int64_t res = 999;\n    int err;\n    err = qemu_strtoll(str, &endptr, 0, &res);\n    g_assert_cmpint(err, ==, 0);\n    g_assert_cmpint(res, ==, 0);\n    g_assert(endptr == str);\n}","8431":"static void put_uint8(QEMUFile *f, void *pv, size_t size)\n{\n    uint8_t *v = pv;\n    qemu_put_8s(f, v);\n}","21925":"static int hls_read_header(AVFormatContext *s)\n{\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n    HLSContext *c = s->priv_data;\n    int ret = 0, i;\n    int highest_cur_seq_no = 0;\n    c->ctx                = s;\n    c->interrupt_callback = &s->interrupt_callback;\n    c->strict_std_compliance = s->strict_std_compliance;\n    c->first_packet = 1;\n    c->first_timestamp = AV_NOPTS_VALUE;\n    c->cur_timestamp = AV_NOPTS_VALUE;\n    if (u) {\n        \n        update_options(&c->user_agent, \"user-agent\", u);\n        \n        update_options(&c->cookies, \"cookies\", u);\n        \n        update_options(&c->headers, \"headers\", u);\n        \n        update_options(&c->http_proxy, \"http_proxy\", u);\n    }\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n    if ((ret = save_avio_options(s)) < 0)\n        goto fail;\n    \n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    \n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n        for (i = 0; i < c->n_playlists; i++) {\n            struct playlist *pls = c->playlists[i];\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n                goto fail;\n        }\n    }\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    \n    if (c->variants[0]->playlists[0]->finished) {\n        int64_t duration = 0;\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n        s->duration = duration;\n    }\n    \n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n        if (var->audio_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n        if (var->video_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n        if (var->subtitles_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n    }\n    \n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        AVProgram *program;\n        program = av_new_program(s, i);\n        if (!program)\n            goto fail;\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n    }\n    \n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        if (pls->n_segments == 0)\n            continue;\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n    }\n    \n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        AVInputFormat *in_fmt = NULL;\n        if (!(pls->ctx = avformat_alloc_context())) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        if (pls->n_segments == 0)\n            continue;\n        pls->index  = i;\n        pls->needed = 1;\n        pls->parent = s;\n        \n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n            pls->cur_seq_no = highest_cur_seq_no;\n        }\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n        if (!pls->read_buffer){\n            ret = AVERROR(ENOMEM);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n                          read_data, NULL, NULL);\n        pls->pb.seekable = 0;\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n                                    NULL, 0, 0);\n        if (ret < 0) {\n            \n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        pls->ctx->pb       = &pls->pb;\n        pls->ctx->io_open  = nested_io_open;\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n            goto fail;\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n        if (ret < 0)\n            goto fail;\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n            avformat_queue_attached_pictures(pls->ctx);\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n            pls->id3_deferred_extra = NULL;\n        }\n        if (pls->is_id3_timestamped == -1)\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n        \n        if (pls->is_id3_timestamped) {\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n            if (ret < 0)\n                goto fail;\n        }\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n        \n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0)\n            goto fail;\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n    }\n    update_noheader_flag(s);\n    return 0;\nfail:\n    free_playlist_list(c);\n    free_variant_list(c);\n    free_rendition_list(c);\n    return ret;\n}","6025":"void qemu_system_reset(void)\n{\n    QEMUResetEntry *re, *nre;\n    \n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n        re->func(re->opaque);\n    }\n}","24483":"static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)\n{\n    int rd = mmreg((ctx->opcode >> 3) & 0x7);\n    int rs = mmreg(ctx->opcode & 0x7);\n    int opc;\n    switch (((ctx->opcode) >> 4) & 0x3f) {\n    case NOT16 + 0:\n    case NOT16 + 1:\n    case NOT16 + 2:\n    case NOT16 + 3:\n        gen_logic(ctx, OPC_NOR, rd, rs, 0);\n        break;\n    case XOR16 + 0:\n    case XOR16 + 1:\n    case XOR16 + 2:\n    case XOR16 + 3:\n        gen_logic(ctx, OPC_XOR, rd, rd, rs);\n        break;\n    case AND16 + 0:\n    case AND16 + 1:\n    case AND16 + 2:\n    case AND16 + 3:\n        gen_logic(ctx, OPC_AND, rd, rd, rs);\n        break;\n    case OR16 + 0:\n    case OR16 + 1:\n    case OR16 + 2:\n    case OR16 + 3:\n        gen_logic(ctx, OPC_OR, rd, rd, rs);\n        break;\n    case LWM16 + 0:\n    case LWM16 + 1:\n    case LWM16 + 2:\n    case LWM16 + 3:\n        {\n            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n            int offset = ZIMM(ctx->opcode, 0, 4);\n            gen_ldst_multiple(ctx, LWM32, lwm_convert[(ctx->opcode >> 4) & 0x3],\n                              29, offset << 2);\n        }\n        break;\n    case SWM16 + 0:\n    case SWM16 + 1:\n    case SWM16 + 2:\n    case SWM16 + 3:\n        {\n            static const int swm_convert[] = { 0x11, 0x12, 0x13, 0x14 };\n            int offset = ZIMM(ctx->opcode, 0, 4);\n            gen_ldst_multiple(ctx, SWM32, swm_convert[(ctx->opcode >> 4) & 0x3],\n                              29, offset << 2);\n        }\n        break;\n    case JR16 + 0:\n    case JR16 + 1:\n        {\n            int reg = ctx->opcode & 0x1f;\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n        }\n        *is_branch = 1;\n        break;\n    case JRC16 + 0:\n    case JRC16 + 1:\n        {\n            int reg = ctx->opcode & 0x1f;\n            gen_compute_branch(ctx, OPC_JR, 2, reg, 0, 0);\n            \n        }\n        break;\n    case JALR16 + 0:\n    case JALR16 + 1:\n        opc = OPC_JALR;\n        goto do_jalr;\n    case JALR16S + 0:\n    case JALR16S + 1:\n        opc = OPC_JALRS;\n    do_jalr:\n        {\n            int reg = ctx->opcode & 0x1f;\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n        }\n        *is_branch = 1;\n        break;\n    case MFHI16 + 0:\n    case MFHI16 + 1:\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n        break;\n    case MFLO16 + 0:\n    case MFLO16 + 1:\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n        break;\n    case BREAK16:\n        generate_exception(ctx, EXCP_BREAK);\n        break;\n    case SDBBP16:\n        \n        check_insn(ctx, ISA_MIPS32);\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n            generate_exception(ctx, EXCP_DBp);\n        } else {\n            generate_exception(ctx, EXCP_DBp);\n        }\n        break;\n    case JRADDIUSP + 0:\n    case JRADDIUSP + 1:\n        {\n            int imm = ZIMM(ctx->opcode, 0, 5);\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n            \n        }\n        break;\n    default:\n        generate_exception(ctx, EXCP_RI);\n        break;\n    }\n}","18409":"int64_t qmp_guest_fsfreeze_freeze(Error **err)\n{\n    int ret = 0, i = 0;\n    FsMountList mounts;\n    struct FsMount *mount;\n    Error *local_err = NULL;\n    int fd;\n    slog(\"guest-fsfreeze called\");\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n    if (error_is_set(&local_err)) {\n        error_propagate(err, local_err);\n        return -1;\n    }\n    QTAILQ_INIT(&mounts);\n    build_fs_mount_list(&mounts, &local_err);\n    if (error_is_set(&local_err)) {\n        error_propagate(err, local_err);\n        return -1;\n    }\n    \n    ga_set_frozen(ga_state);\n    QTAILQ_FOREACH(mount, &mounts, next) {\n        fd = qemu_open(mount->dirname, O_RDONLY);\n        if (fd == -1) {\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n            goto error;\n        }\n        \n        ret = ioctl(fd, FIFREEZE);\n        if (ret == -1) {\n            if (errno != EOPNOTSUPP) {\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n                                 mount->dirname);\n                close(fd);\n                goto error;\n            }\n        } else {\n            i++;\n        }\n        close(fd);\n    }\n    free_fs_mount_list(&mounts);\n    return i;\nerror:\n    free_fs_mount_list(&mounts);\n    qmp_guest_fsfreeze_thaw(NULL);\n    return 0;\n}","7267":"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n                             void *opaque, Error **errp)\n{\n    uint64_t value;\n    MemoryRegion *mr;\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n    mr = ddc->get_memory_region(dimm);\n    value = memory_region_size(mr);\n    visit_type_uint64(v, name, &value, errp);\n}","2620":"void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n{\n    CPUArchState *env;\n    int mmu_idx;\n    assert_cpu_is_self(cpu);\n    env = cpu->env_ptr;\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n        unsigned int i;\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n                                  start1, length);\n        }\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n                                  start1, length);\n        }\n    }\n}","13114":"void pl011_init(uint32_t base, qemu_irq irq,\n                CharDriverState *chr)\n{\n    int iomemtype;\n    pl011_state *s;\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n                                       pl011_writefn, s);\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n    s->base = base;\n    s->irq = irq;\n    s->chr = chr;\n    s->read_trigger = 1;\n    s->ifl = 0x12;\n    s->cr = 0x300;\n    s->flags = 0x90;\n    if (chr){ \n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n                              pl011_event, s);\n    }\n    \n}","22006":"bool timerlist_expired(QEMUTimerList *timer_list)\n{\n    int64_t expire_time;\n    if (!atomic_read(&timer_list->active_timers)) {\n        return false;\n    }\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n    if (!timer_list->active_timers) {\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n        return false;\n    }\n    expire_time = timer_list->active_timers->expire_time;\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n}","21335":"int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n                       void *opaque, int version_id)\n{\n    VMStateField *field = vmsd->fields;\n    int ret = 0;\n    trace_vmstate_load_state(vmsd->name, version_id);\n    if (version_id > vmsd->version_id) {\n        error_report(\"%s: incoming version_id %d is too new \"\n                     \"for local version_id %d\",\n                     vmsd->name, version_id, vmsd->version_id);\n        trace_vmstate_load_state_end(vmsd->name, \"too new\", -EINVAL);\n        return -EINVAL;\n    }\n    if  (version_id < vmsd->minimum_version_id) {\n        if (vmsd->load_state_old &&\n            version_id >= vmsd->minimum_version_id_old) {\n            ret = vmsd->load_state_old(f, opaque, version_id);\n            trace_vmstate_load_state_end(vmsd->name, \"old path\", ret);\n            return ret;\n        }\n        error_report(\"%s: incoming version_id %d is too old \"\n                     \"for local minimum version_id  %d\",\n                     vmsd->name, version_id, vmsd->minimum_version_id);\n        trace_vmstate_load_state_end(vmsd->name, \"too old\", -EINVAL);\n        return -EINVAL;\n    }\n    if (vmsd->pre_load) {\n        int ret = vmsd->pre_load(opaque);\n        if (ret) {\n            return ret;\n        }\n    }\n    while (field->name) {\n        trace_vmstate_load_state_field(vmsd->name, field->name);\n        if ((field->field_exists &&\n             field->field_exists(opaque, version_id)) ||\n            (!field->field_exists &&\n             field->version_id <= version_id)) {\n            void *first_elem = opaque + field->offset;\n            int i, n_elems = vmstate_n_elems(opaque, field);\n            int size = vmstate_size(opaque, field);\n            vmstate_handle_alloc(first_elem, field, opaque);\n            if (field->flags & VMS_POINTER) {\n                first_elem = *(void **)first_elem;\n                assert(first_elem  || !n_elems);\n            }\n            for (i = 0; i < n_elems; i++) {\n                void *curr_elem = first_elem + size * i;\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n                    curr_elem = *(void **)curr_elem;\n                }\n                if (field->flags & VMS_STRUCT) {\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n                                             field->vmsd->version_id);\n                } else {\n                    ret = field->info->get(f, curr_elem, size, field);\n                }\n                if (ret >= 0) {\n                    ret = qemu_file_get_error(f);\n                }\n                if (ret < 0) {\n                    qemu_file_set_error(f, ret);\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n                                 field->name);\n                    trace_vmstate_load_field_error(field->name, ret);\n                    return ret;\n                }\n            }\n        } else if (field->flags & VMS_MUST_EXIST) {\n            error_report(\"Input validation failed: %s\/%s\",\n                         vmsd->name, field->name);\n            return -1;\n        }\n        field++;\n    }\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n    if (ret != 0) {\n        return ret;\n    }\n    if (vmsd->post_load) {\n        ret = vmsd->post_load(opaque, version_id);\n    }\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n    return ret;\n}","369":"void stream_start(const char *job_id, BlockDriverState *bs,\n                  BlockDriverState *base, const char *backing_file_str,\n                  int64_t speed, BlockdevOnError on_error,\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n{\n    StreamBlockJob *s;\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n                         cb, opaque, errp);\n    if (!s) {\n        return;\n    }\n    s->base = base;\n    s->backing_file_str = g_strdup(backing_file_str);\n    s->on_error = on_error;\n    s->common.co = qemu_coroutine_create(stream_run);\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n    qemu_coroutine_enter(s->common.co, s);\n}","164":"void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 \/ x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();","7048":"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n{\n    int ret, i;\n    frame->width  = s->avctx->width  + 2;\n    frame->height = s->avctx->height + 2;\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n        return ret;\n    for (i = 0; frame->data[i]; i++) {\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n        frame->data[i] += offset;\n    }\n    frame->width  = s->avctx->width;\n    frame->height = s->avctx->height;\n    return 0;\n}","21007":"static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,\n                      int append)\n{\n    int buflen;\n    \n    if (!append) {\n        s->frame_offset = get_bits_count(gb) & 7;\n        s->num_saved_bits = s->frame_offset;\n        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n    buflen = (s->num_saved_bits + len + 8) >> 3;\n    if (len <= 0 || buflen > MAX_FRAMESIZE) {\n        avpriv_request_sample(s->avctx, \"Too small input buffer\");\n    s->num_saved_bits += len;\n    if (!append) {\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),\n                     s->num_saved_bits);\n    } else {\n        int align = 8 - (get_bits_count(gb) & 7);\n        align = FFMIN(align, len);\n        put_bits(&s->pb, align, get_bits(gb, align));\n        len -= align;\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);\n    skip_bits_long(gb, len);\n    {\n        PutBitContext tmp = s->pb;\n        flush_put_bits(&tmp);\n    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);\n    skip_bits(&s->gb, s->frame_offset);","13739":"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n                                  size_t *count)\n{\n    GIOStatus status;\n    OVERLAPPED ov = {0};\n    BOOL ret;\n    DWORD written;\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n    if (!ret) {\n        if (GetLastError() == ERROR_IO_PENDING) {\n            \n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n            if (!ret) {\n                if (!GetLastError()) {\n                    status = G_IO_STATUS_AGAIN;\n                } else {\n                    status = G_IO_STATUS_ERROR;\n            } else {\n                \n                status = G_IO_STATUS_NORMAL;\n                *count = written;\n        } else {\n            status = G_IO_STATUS_ERROR;\n    } else {\n        \n        status = G_IO_STATUS_NORMAL;\n        *count = written;\n    return status;","20613":"static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,\n                                     const uint8_t *src_in[4], int srcW, int xInc,\n                                     const int16_t *hLumFilter,\n                                     const int16_t *hLumFilterPos, int hLumFilterSize,\n                                     uint8_t *formatConvBuffer,\n                                     uint32_t *pal, int isAlpha)\n{\n    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;\n    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;\n    const uint8_t *src = src_in[isAlpha ? 3 : 0];\n    if (toYV12) {\n        toYV12(formatConvBuffer, src, srcW, pal);\n        src= formatConvBuffer;\n    } else if (c->readLumPlanar && !isAlpha) {\n        c->readLumPlanar(formatConvBuffer, src_in, srcW);\n        src = formatConvBuffer;\n    }\n    if (!c->hyscale_fast) {\n        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);\n    } else { \n        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);\n    }\n    if (convertRange)\n        convertRange(dst, dstWidth);\n}","9509":"static void vga_draw_graphic(VGAState *s, int full_update)\n{\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n    int disp_width, multi_scan, multi_run;\n    uint8_t *d;\n    uint32_t v, addr1, addr;\n    vga_draw_line_func *vga_draw_line;\n    full_update |= update_basic_params(s);\n    if (!full_update)\n        vga_sync_dirty_bitmap(s);\n    s->get_resolution(s, &width, &height);\n    disp_width = width;\n    shift_control = (s->gr[0x05] >> 5) & 3;\n    double_scan = (s->cr[0x09] >> 7);\n    if (shift_control != 1) {\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n    } else {\n        \n        \n        multi_scan = double_scan;\n    }\n    multi_run = multi_scan;\n    if (shift_control != s->shift_control ||\n        double_scan != s->double_scan) {\n        full_update = 1;\n        s->shift_control = shift_control;\n        s->double_scan = double_scan;\n    }\n    if (shift_control == 0) {\n        full_update |= update_palette16(s);\n        if (s->sr[0x01] & 8) {\n            v = VGA_DRAW_LINE4D2;\n            disp_width <<= 1;\n        } else {\n            v = VGA_DRAW_LINE4;\n        }\n        bits = 4;\n    } else if (shift_control == 1) {\n        full_update |= update_palette16(s);\n        if (s->sr[0x01] & 8) {\n            v = VGA_DRAW_LINE2D2;\n            disp_width <<= 1;\n        } else {\n            v = VGA_DRAW_LINE2;\n        }\n        bits = 4;\n    } else {\n        switch(s->get_bpp(s)) {\n        default:\n        case 0:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8D2;\n            bits = 4;\n            break;\n        case 8:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8;\n            bits = 8;\n            break;\n        case 15:\n            v = VGA_DRAW_LINE15;\n            bits = 16;\n            break;\n        case 16:\n            v = VGA_DRAW_LINE16;\n            bits = 16;\n            break;\n        case 24:\n            v = VGA_DRAW_LINE24;\n            bits = 24;\n            break;\n        case 32:\n            v = VGA_DRAW_LINE32;\n            bits = 32;\n            break;\n        }\n    }\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n    depth = s->get_bpp(s);\n    if (s->line_offset != s->last_line_offset ||\n        disp_width != s->last_width ||\n        height != s->last_height ||\n        s->last_depth != depth) {\n        if (depth == 16 || depth == 32) {\n            if (is_graphic_console()) {\n                qemu_free_displaysurface(s->ds->surface);\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n                                                               s->line_offset,\n                                                               s->vram_ptr + (s->start_addr * 4));\n                dpy_resize(s->ds);\n            } else {\n                qemu_console_resize(s->ds, disp_width, height);\n            }\n        } else {\n            qemu_console_resize(s->ds, disp_width, height);\n        }\n        s->last_scr_width = disp_width;\n        s->last_scr_height = height;\n        s->last_width = disp_width;\n        s->last_height = height;\n        s->last_line_offset = s->line_offset;\n        s->last_depth = depth;\n        full_update = 1;\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n        dpy_setdata(s->ds);\n    }\n    s->rgb_to_pixel =\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n        s->cursor_invalidate(s);\n    line_offset = s->line_offset;\n#if 0\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n#endif\n    addr1 = (s->start_addr * 4);\n    bwidth = (width * bits + 7) \/ 8;\n    y_start = -1;\n    page_min = 0x7fffffff;\n    page_max = -1;\n    d = ds_get_data(s->ds);\n    linesize = ds_get_linesize(s->ds);\n    y1 = 0;\n    for(y = 0; y < height; y++) {\n        addr = addr1;\n        if (!(s->cr[0x17] & 1)) {\n            int shift;\n            \n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n        }\n        if (!(s->cr[0x17] & 2)) {\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n        }\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n        update = full_update |\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n            \n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n                                                    VGA_DIRTY_FLAG);\n        }\n        \n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n        if (update) {\n            if (y_start < 0)\n                y_start = y;\n            if (page0 < page_min)\n                page_min = page0;\n            if (page1 > page_max)\n                page_max = page1;\n            if (!(is_buffer_shared(s->ds->surface))) {\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n                if (s->cursor_draw_line)\n                    s->cursor_draw_line(s, d, y);\n            }\n        } else {\n            if (y_start >= 0) {\n                \n                dpy_update(s->ds, 0, y_start,\n                           disp_width, y - y_start);\n                y_start = -1;\n            }\n        }\n        if (!multi_run) {\n            mask = (s->cr[0x17] & 3) ^ 3;\n            if ((y1 & mask) == mask)\n                addr1 += line_offset;\n            y1++;\n            multi_run = multi_scan;\n        } else {\n            multi_run--;\n        }\n        \n        if (y == s->line_compare)\n            addr1 = 0;\n        d += linesize;\n    }\n    if (y_start >= 0) {\n        \n        dpy_update(s->ds, 0, y_start,\n                   disp_width, y - y_start);\n    }\n    \n    if (page_max != -1) {\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n                                        VGA_DIRTY_FLAG);\n    }\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n}","7521":"static void monitor_find_completion(const char *cmdline)\n{\n    const char *cmdname;\n    char *args[MAX_ARGS];\n    int nb_args, i, len;\n    const char *ptype, *str;\n    const mon_cmd_t *cmd;\n    const KeyDef *key;\n    parse_cmdline(cmdline, &nb_args, args);\n#ifdef DEBUG_COMPLETION\n    for(i = 0; i < nb_args; i++) {\n        monitor_printf(cur_mon, \"arg%d = '%s'\\n\", i, (char *)args[i]);\n    }\n#endif\n    \n    len = strlen(cmdline);\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n        if (nb_args >= MAX_ARGS)\n            return;\n        args[nb_args++] = qemu_strdup(\"\");\n    }\n    if (nb_args <= 1) {\n        \n        if (nb_args == 0)\n            cmdname = \"\";\n        else\n            cmdname = args[0];\n        readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n            cmd_completion(cmdname, cmd->name);\n        }\n    } else {\n        \n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n            if (compare_cmd(args[0], cmd->name))\n                goto found;\n        }\n        return;\n    found:\n        ptype = next_arg_type(cmd->args_type);\n        for(i = 0; i < nb_args - 2; i++) {\n            if (*ptype != '\\0') {\n                ptype = next_arg_type(ptype);\n                while (*ptype == '?')\n                    ptype = next_arg_type(ptype);\n            }\n        }\n        str = args[nb_args - 1];\n        if (*ptype == '-' && ptype[1] != '\\0') {\n            ptype += 2;\n        }\n        switch(*ptype) {\n        case 'F':\n            \n            readline_set_completion_index(cur_mon->rs, strlen(str));\n            file_completion(str);\n            break;\n        case 'B':\n            \n            readline_set_completion_index(cur_mon->rs, strlen(str));\n            bdrv_iterate(block_completion_it, (void *)str);\n            break;\n        case 's':\n            \n            if (!strcmp(cmd->name, \"info\")) {\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n                    cmd_completion(str, cmd->name);\n                }\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n                char *sep = strrchr(str, '-');\n                if (sep)\n                    str = sep + 1;\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n                for(key = key_defs; key->name != NULL; key++) {\n                    cmd_completion(str, key->name);\n                }\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n                    cmd_completion(str, cmd->name);\n                }\n            }\n            break;\n        default:\n            break;\n        }\n    }\n    for(i = 0; i < nb_args; i++)\n        qemu_free(args[i]);\n}","23786":"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n                            AVPacket *avpkt) {\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    PCXContext * const s = avctx->priv_data;\n    AVFrame *picture = data;\n    AVFrame * const p = &s->picture;\n    int compressed, xmin, ymin, xmax, ymax;\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n                 bytes_per_scanline;\n    uint8_t *ptr;\n    uint8_t const *bufstart = buf;\n    uint8_t *scanline;\n    int ret = -1;\n    if (buf[0] != 0x0a || buf[1] > 5) {\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    compressed = buf[2];\n    xmin = AV_RL16(buf+ 4);\n    ymin = AV_RL16(buf+ 6);\n    xmax = AV_RL16(buf+ 8);\n    ymax = AV_RL16(buf+10);\n    if (xmax < xmin || ymax < ymin) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    w = xmax - xmin + 1;\n    h = ymax - ymin + 1;\n    bits_per_pixel     = buf[3];\n    bytes_per_line     = AV_RL16(buf+66);\n    nplanes            = buf[65];\n    bytes_per_scanline = nplanes * bytes_per_line;\n    if (bytes_per_scanline < w * bits_per_pixel * nplanes \/ 8) {\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    switch ((nplanes<<8) + bits_per_pixel) {\n        case 0x0308:\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n            break;\n        case 0x0108:\n        case 0x0104:\n        case 0x0102:\n        case 0x0101:\n        case 0x0401:\n        case 0x0301:\n        case 0x0201:\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n            return AVERROR_INVALIDDATA;\n    }\n    buf += 128;\n    if (p->data[0])\n        avctx->release_buffer(avctx, p);\n    if (av_image_check_size(w, h, 0, avctx))\n        return AVERROR_INVALIDDATA;\n    if (w != avctx->width || h != avctx->height)\n        avcodec_set_dimensions(avctx, w, h);\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    p->pict_type = AV_PICTURE_TYPE_I;\n    ptr    = p->data[0];\n    stride = p->linesize[0];\n    scanline = av_malloc(bytes_per_scanline);\n    if (!scanline)\n        return AVERROR(ENOMEM);\n    if (nplanes == 3 && bits_per_pixel == 8) {\n        for (y=0; y<h; y++) {\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n            for (x=0; x<w; x++) {\n                ptr[3*x  ] = scanline[x                    ];\n                ptr[3*x+1] = scanline[x+ bytes_per_line    ];\n                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];\n            }\n            ptr += stride;\n        }\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n        const uint8_t *palstart = bufstart + buf_size - 769;\n        for (y=0; y<h; y++, ptr+=stride) {\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n            memcpy(ptr, scanline, w);\n        }\n        if (buf != palstart) {\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n            buf = palstart;\n        }\n        if (*buf++ != 12) {\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n    } else if (nplanes == 1) {   \n        GetBitContext s;\n        for (y=0; y<h; y++) {\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n            for (x=0; x<w; x++)\n                ptr[x] = get_bits(&s, bits_per_pixel);\n            ptr += stride;\n        }\n    } else {    \n        int i;\n        for (y=0; y<h; y++) {\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n            for (x=0; x<w; x++) {\n                int m = 0x80 >> (x&7), v = 0;\n                for (i=nplanes - 1; i>=0; i--) {\n                    v <<= 1;\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n                }\n                ptr[x] = v;\n            }\n            ptr += stride;\n        }\n    }\n    if (nplanes == 1 && bits_per_pixel == 8) {\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n    } else if (bits_per_pixel * nplanes == 1) {\n        AV_WN32A(p->data[1]  , 0xFF000000);\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n    } else if (bits_per_pixel < 8) {\n        const uint8_t *palette = bufstart+16;\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n    }\n    *picture = s->picture;\n    *data_size = sizeof(AVFrame);\n    ret = buf - bufstart;\nend:\n    av_free(scanline);\n    return ret;\n}","21919":"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n    c->bytestream_start=\n    c->bytestream= buf;\n    c->bytestream_end= buf + buf_size;\n#if CABAC_BITS == 16\n    c->low =  (*c->bytestream++)<<18;\n    c->low+=  (*c->bytestream++)<<10;\n#else\n    c->low =  (*c->bytestream++)<<10;\n#endif\n    c->low+= ((*c->bytestream++)<<2) + 2;\n    c->range= 0x1FE;\n}","3824":"static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n{\n    struct cow_header_v2 cow_header;\n    struct stat st;\n    int64_t image_sectors = 0;\n    char *image_filename = NULL;\n    Error *local_err = NULL;\n    int ret;\n    BlockDriverState *cow_bs;\n    \n    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) \/ 512;\n    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n    ret = bdrv_create_file(filename, opts, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        goto exit;\n    }\n    cow_bs = NULL;\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n        goto exit;\n    }\n    memset(&cow_header, 0, sizeof(cow_header));\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n    cow_header.version = cpu_to_be32(COW_VERSION);\n    if (image_filename) {\n        \n        cow_header.mtime = cpu_to_be32(0);\n        if (stat(image_filename, &st) != 0) {\n            goto mtime_fail;\n        }\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n    mtime_fail:\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n                image_filename);\n    }\n    cow_header.sectorsize = cpu_to_be32(512);\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n    if (ret < 0) {\n        goto exit;\n    }\n    \n    ret = bdrv_truncate(cow_bs,\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n    if (ret < 0) {\n        goto exit;\n    }\nexit:\n    g_free(image_filename);\n    bdrv_unref(cow_bs);\n    return ret;\n}","16933":"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n{\n    int i;\n    assert(dest->niov == source->niov);\n    assert(dest->size == source->size);\n    for (i = 0; i < source->niov; i++) {\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n        memcpy(dest->iov[i].iov_base,\n               source->iov[i].iov_base,\n               source->iov[i].iov_len);\n    }\n}","14366":"const AVOption *av_opt_next(void *obj, const AVOption *last)\n{\n    AVClass *class = *(AVClass**)obj;\n    if (!last && class->option[0].name) return class->option;\n    if (last && last[1].name)           return ++last;\n    return NULL;\n}","16370":"static int ftp_abort(URLContext *h)\n{\n    static const char *command = \"ABOR\\r\\n\";\n    int err;\n    static const int abor_codes[] = {225, 226, 0};\n    FTPContext *s = h->priv_data;\n    \n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n        ftp_close_both_connections(s);\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n            return err;\n        }\n    } else {\n        ftp_close_data_connection(s);\n    }\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n        \n        ffurl_closep(&s->conn_control);\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n            return err;\n        }\n    }\n    return 0;\n}","10801":"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n{\n    AHCICmdHdr *cmd = ad->cur_cmd;\n    uint32_t opts = le32_to_cpu(cmd->opts);\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n    int i;\n    int r = 0;\n    int sum = 0;\n    int off_idx = -1;\n    int off_pos = -1;\n    int tbl_entry_size;\n    IDEBus *bus = &ad->port;\n    BusState *qbus = BUS(bus);\n    if (!sglist_alloc_hint) {\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n        return -1;\n    }\n    \n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n                                DMA_DIRECTION_TO_DEVICE))){\n        DPRINTF(ad->port_no, \"map failed\\n\");\n        return -1;\n    }\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n    \n    if (sglist_alloc_hint > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < sglist_alloc_hint; i++) {\n            \n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n            if (offset <= (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %d\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n                         ad->hba->as);\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n            \n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n        }\n    }\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n    return r;\n}","20600":"static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,\n                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],\n                      GetBitContext *gb)\n{\n    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;\n    int comment_len;\n    skip_bits(gb, 2);  \n    sampling_index = get_bits(gb, 4);\n    if (m4ac->sampling_index != sampling_index)\n        av_log(avctx, AV_LOG_WARNING, \"Sample rate index in program config element does not match the sample rate index configured by the container.\\n\");\n    num_front       = get_bits(gb, 4);\n    num_side        = get_bits(gb, 4);\n    num_back        = get_bits(gb, 4);\n    num_lfe         = get_bits(gb, 2);\n    num_assoc_data  = get_bits(gb, 3);\n    num_cc          = get_bits(gb, 4);\n    if (get_bits1(gb))\n        skip_bits(gb, 4); \n    if (get_bits1(gb))\n        skip_bits(gb, 4); \n    if (get_bits1(gb))\n        skip_bits(gb, 3); \n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );\n    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );\n    skip_bits_long(gb, 4 * num_assoc_data);\n    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );\n    align_get_bits(gb);\n    \n    comment_len = get_bits(gb, 8) * 8;\n    if (get_bits_left(gb) < comment_len) {\n    skip_bits_long(gb, comment_len);\n    return 0;","17353":"static void matroska_add_index_entries(MatroskaDemuxContext *matroska)\n{\n    EbmlList *index_list;\n    MatroskaIndex *index;\n    int index_scale = 1;\n    int i, j;\n    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)\n        return;\n    index_list = &matroska->index;\n    index      = index_list->elem;\n    if (index_list->nb_elem &&\n        index[0].time > 1E14 \/ matroska->time_scale) {\n        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");\n        index_scale = matroska->time_scale;\n    }\n    for (i = 0; i < index_list->nb_elem; i++) {\n        EbmlList *pos_list    = &index[i].pos;\n        MatroskaIndexPos *pos = pos_list->elem;\n        for (j = 0; j < pos_list->nb_elem; j++) {\n            MatroskaTrack *track = matroska_find_track_by_num(matroska,\n                                                              pos[j].track);\n            if (track && track->stream)\n                av_add_index_entry(track->stream,\n                                   pos[j].pos + matroska->segment_start,\n                                   index[i].time \/ index_scale, 0, 0,\n                                   AVINDEX_KEYFRAME);\n        }\n    }\n}","13429":"static int dshow_read_header(AVFormatContext *avctx)\n{\n    struct dshow_ctx *ctx = avctx->priv_data;\n    IGraphBuilder *graph = NULL;\n    ICreateDevEnum *devenum = NULL;\n    IMediaControl *control = NULL;\n    IMediaEvent *media_event = NULL;\n    HANDLE media_event_handle;\n    HANDLE proc;\n    int ret = AVERROR(EIO);\n    int r;\n    CoInitialize(0);\n    if (!ctx->list_devices && !parse_device_name(avctx)) {\n        av_log(avctx, AV_LOG_ERROR, \"Malformed dshow input string.\\n\");\n        goto error;\n    }\n    ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id\n                                                : AV_CODEC_ID_RAWVIDEO;\n    if (ctx->pixel_format != AV_PIX_FMT_NONE) {\n        if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) {\n            av_log(avctx, AV_LOG_ERROR, \"Pixel format may only be set when \"\n                              \"video codec is not set or set to rawvideo\\n\");\n            ret = AVERROR(EINVAL);\n            goto error;\n        }\n    }\n    if (ctx->framerate) {\n        r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate);\n        if (r < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Could not parse framerate '%s'.\\n\", ctx->framerate);\n            goto error;\n        }\n    }\n    r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,\n                         &IID_IGraphBuilder, (void **) &graph);\n    if (r != S_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not create capture graph.\\n\");\n        goto error;\n    }\n    ctx->graph = graph;\n    r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,\n                         &IID_ICreateDevEnum, (void **) &devenum);\n    if (r != S_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate system devices.\\n\");\n        goto error;\n    }\n    if (ctx->list_devices) {\n        av_log(avctx, AV_LOG_INFO, \"DirectShow video devices\\n\");\n        dshow_cycle_devices(avctx, devenum, VideoDevice, NULL);\n        av_log(avctx, AV_LOG_INFO, \"DirectShow audio devices\\n\");\n        dshow_cycle_devices(avctx, devenum, AudioDevice, NULL);\n        ret = AVERROR_EXIT;\n        goto error;\n    }\n    if (ctx->list_options) {\n        if (ctx->device_name[VideoDevice])\n            dshow_list_device_options(avctx, devenum, VideoDevice);\n        if (ctx->device_name[AudioDevice])\n            dshow_list_device_options(avctx, devenum, AudioDevice);\n        ret = AVERROR_EXIT;\n        goto error;\n    }\n    if (ctx->device_name[VideoDevice]) {\n        if ((r = dshow_open_device(avctx, devenum, VideoDevice)) < 0 ||\n            (r = dshow_add_device(avctx, VideoDevice)) < 0) {\n            ret = r;\n            goto error;\n        }\n    }\n    if (ctx->device_name[AudioDevice]) {\n        if ((r = dshow_open_device(avctx, devenum, AudioDevice)) < 0 ||\n            (r = dshow_add_device(avctx, AudioDevice)) < 0) {\n            ret = r;\n            goto error;\n        }\n    }\n    ctx->mutex = CreateMutex(NULL, 0, NULL);\n    if (!ctx->mutex) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Mutex\\n\");\n        goto error;\n    }\n    ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);\n    if (!ctx->event[1]) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Event\\n\");\n        goto error;\n    }\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);\n    if (r != S_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media control.\\n\");\n        goto error;\n    }\n    ctx->control = control;\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);\n    if (r != S_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event.\\n\");\n        goto error;\n    }\n    ctx->media_event = media_event;\n    r = IMediaEvent_GetEventHandle(media_event, (void *) &media_event_handle);\n    if (r != S_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event handle.\\n\");\n        goto error;\n    }\n    proc = GetCurrentProcess();\n    r = DuplicateHandle(proc, media_event_handle, proc, &ctx->event[0],\n                        0, 0, DUPLICATE_SAME_ACCESS);\n    if (!r) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not duplicate media event handle.\\n\");\n        goto error;\n    }\n    r = IMediaControl_Run(control);\n    if (r == S_FALSE) {\n        OAFilterState pfs;\n        r = IMediaControl_GetState(control, 0, &pfs);\n    }\n    if (r != S_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not run filter\\n\");\n        goto error;\n    }\n    ret = 0;\nerror:\n    if (devenum)\n        ICreateDevEnum_Release(devenum);\n    if (ret < 0)\n        dshow_read_close(avctx);\n    return ret;\n}","4009":"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n                                    const uint8_t *src, const uint8_t *src_end,\n                                    int width, int esc_count)\n{\n    int i = 0;\n    int count;\n    uint8_t zero_run = 0;\n    const uint8_t *src_start = src;\n    uint8_t mask1 = -(esc_count < 2);\n    uint8_t mask2 = -(esc_count < 3);\n    uint8_t *end = dst + (width - 2);\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n    return AVERROR_PATCHWELCOME;\noutput_zeros:\n    if (l->zeros_rem) {\n        count = FFMIN(l->zeros_rem, width - i);\n        if (end - dst < count) {\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        memset(dst, 0, count);\n        l->zeros_rem -= count;\n        dst += count;\n    }\n    while (dst < end) {\n        i = 0;\n        while (!zero_run && dst + i < end) {\n            i++;\n            if (i+2 >= src_end - src)\n                return AVERROR_INVALIDDATA;\n            zero_run =\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n        }\n        if (zero_run) {\n            zero_run = 0;\n            i += esc_count;\n            memcpy(dst, src, i);\n            dst += i;\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n            src += i + 1;\n            goto output_zeros;\n        } else {\n            memcpy(dst, src, i);\n            src += i;\n            dst += i;\n        }\n    }\n    return  src - src_start;\n}","6543":"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf  = s->priv_data;\n    AVIOContext *pb  = s->pb;\n    uint64_t size    = avio_rl64(pb);\n    uint16_t nb_desc = avio_rl16(pb);\n    int i, ret;\n    for (i = 0; i < nb_desc; i++) {\n        uint16_t name_len, type, val_len;\n        uint8_t *name = NULL;\n        name_len = avio_rl16(pb);\n        if (!name_len)\n            return AVERROR_INVALIDDATA;\n        name = av_malloc(name_len);\n        if (!name)\n            return AVERROR(ENOMEM);\n        avio_get_str16le(pb, name_len, name,\n                         name_len);\n        type    = avio_rl16(pb);\n        val_len = avio_rl16(pb);\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n            return ret;\n    }\n    align_position(pb, asf->offset, size);\n    return 0;\n}","13740":"int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)\n{\n    int ret = 0;\n    AVBPrint bp;\n    char *name = NULL;\n    char *message = NULL;\n    jclass class_class = NULL;\n    jmethodID get_name_id = NULL;\n    jclass exception_class = NULL;\n    jmethodID get_message_id = NULL;\n    jstring string;\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n    exception_class = (*env)->GetObjectClass(env, exception);\n    if ((*env)->ExceptionCheck(env)) {\n        (*env)->ExceptionClear(env);\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class\\n\");\n        ret = AVERROR_EXTERNAL;\n        goto done;\n    }\n    class_class = (*env)->GetObjectClass(env, exception_class);\n    if ((*env)->ExceptionCheck(env)) {\n        (*env)->ExceptionClear(env);\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class's class\\n\");\n        ret = AVERROR_EXTERNAL;\n        goto done;\n    }\n    get_name_id = (*env)->GetMethodID(env, class_class, \"getName\", \"()Ljava\/lang\/String;\");\n    if ((*env)->ExceptionCheck(env)) {\n        (*env)->ExceptionClear(env);\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method Class.getName()\\n\");\n        ret = AVERROR_EXTERNAL;\n        goto done;\n    }\n    string = (*env)->CallObjectMethod(env, exception_class, get_name_id);\n    if ((*env)->ExceptionCheck(env)) {\n        (*env)->ExceptionClear(env);\n        av_log(log_ctx, AV_LOG_ERROR, \"Class.getName() threw an exception\\n\");\n        ret = AVERROR_EXTERNAL;\n        goto done;\n    }\n    if (string) {\n        name = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n        (*env)->DeleteLocalRef(env, string);\n        string = NULL;\n    }\n    get_message_id = (*env)->GetMethodID(env, exception_class, \"getMessage\", \"()Ljava\/lang\/String;\");\n    if ((*env)->ExceptionCheck(env)) {\n        (*env)->ExceptionClear(env);\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method java\/lang\/Throwable.getMessage()\\n\");\n        ret = AVERROR_EXTERNAL;\n        goto done;\n    }\n    string = (*env)->CallObjectMethod(env, exception, get_message_id);\n    if ((*env)->ExceptionCheck(env)) {\n        (*env)->ExceptionClear(env);\n        av_log(log_ctx, AV_LOG_ERROR, \"Throwable.getMessage() threw an exception\\n\");\n        ret = AVERROR_EXTERNAL;\n        goto done;\n    }\n    if (string) {\n        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n        (*env)->DeleteLocalRef(env, string);\n        string = NULL;\n    }\n    if (name && message) {\n        av_bprintf(&bp, \"%s: %s\", name, message);\n    } else if (name && !message) {\n        av_bprintf(&bp, \"%s occurred\", name);\n    } else if (!name && message) {\n        av_bprintf(&bp, \"Exception: %s\", message);\n    } else {\n        av_log(log_ctx, AV_LOG_WARNING, \"Could not retreive exception name and message\\n\");\n        av_bprintf(&bp, \"Exception occurred\");\n    }\n    ret = av_bprint_finalize(&bp, error);\ndone:\n    av_free(name);\n    av_free(message);\n    if (class_class) {\n        (*env)->DeleteLocalRef(env, class_class);\n    }\n    if (exception_class) {\n        (*env)->DeleteLocalRef(env, exception_class);\n    }\n    if (string) {\n        (*env)->DeleteLocalRef(env, string);\n    }\n    return ret;\n}","26100":"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)\n{\n    if (!mb_x) {\n        return mb_y ? VERT_VP8_PRED : DC_129_PRED;\n    } else {\n        return mb_y ? mode : HOR_VP8_PRED;\n    }\n}","19912":"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n{\n    IVI45DecContext *ctx = avctx->priv_data;\n    ivi_free_buffers(&ctx->planes[0]);\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n    av_frame_free(&ctx->p_frame);\n    return 0;\n}","9934":"int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)\n{\n    int i;\n    for (i = 0; i < 256; i++) {\n        int r, g, b;\n        switch (pix_fmt) {\n        case AV_PIX_FMT_RGB8:\n            r = (i>>5    )*36;\n            g = ((i>>2)&7)*36;\n            b = (i&3     )*85;\n            break;\n        case AV_PIX_FMT_BGR8:\n            b = (i>>6    )*85;\n            g = ((i>>3)&7)*36;\n            r = (i&7     )*36;\n            break;\n        case AV_PIX_FMT_RGB4_BYTE:\n            r = (i>>3    )*255;\n            g = ((i>>1)&3)*85;\n            b = (i&1     )*255;\n            break;\n        case AV_PIX_FMT_BGR4_BYTE:\n            b = (i>>3    )*255;\n            g = ((i>>1)&3)*85;\n            r = (i&1     )*255;\n            break;\n        case AV_PIX_FMT_GRAY8:\n            r = b = g = i;\n            break;\n        default:\n            return AVERROR(EINVAL);\n        }\n        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);\n    }\n    return 0;\n}","26315":"static void bdrv_co_drain_bh_cb(void *opaque)\n{\n    BdrvCoDrainData *data = opaque;\n    Coroutine *co = data->co;\n    qemu_bh_delete(data->bh);\n    bdrv_drain_poll(data->bs);\n    data->done = true;\n    qemu_coroutine_enter(co, NULL);\n}","7191":"static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n                               struct qht_bucket *head, void *p, uint32_t hash,\n                               bool *needs_resize)\n{\n    struct qht_bucket *b = head;\n    struct qht_bucket *prev = NULL;\n    struct qht_bucket *new = NULL;\n    int i;\n    do {\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n            if (b->pointers[i]) {\n                if (unlikely(b->pointers[i] == p)) {\n                    return false;\n                }\n            } else {\n                goto found;\n            }\n        }\n        prev = b;\n        b = b->next;\n    } while (b);\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n    memset(b, 0, sizeof(*b));\n    new = b;\n    i = 0;\n    atomic_inc(&map->n_added_buckets);\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n        *needs_resize = true;\n    }\n found:\n    \n    seqlock_write_begin(&head->sequence);\n    if (new) {\n        atomic_rcu_set(&prev->next, b);\n    }\n    b->hashes[i] = hash;\n    \n    atomic_set(&b->pointers[i], p);\n    seqlock_write_end(&head->sequence);\n    return true;\n}","13888":"static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n                        const uint8_t **poutbuf, int *poutbuf_size,\n                        const uint8_t *buf, int buf_size)\n{\n    VorbisParseContext *s = s1->priv_data;\n    int duration;\n    if (!s->vp && avctx->extradata && avctx->extradata_size) {\n        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);\n        if (!s->vp)\n            goto end;\n    }\n    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)\n        s1->duration = duration;\nend:\n    \n    *poutbuf      = buf;\n    *poutbuf_size = buf_size;\n    return buf_size;\n}","10773":"static av_cold int svq1_encode_init(AVCodecContext *avctx)\n{\n    SVQ1Context * const s = avctx->priv_data;\n    dsputil_init(&s->dsp, avctx);\n    avctx->coded_frame= (AVFrame*)&s->picture;\n    s->frame_width = avctx->width;\n    s->frame_height = avctx->height;\n    s->y_block_width = (s->frame_width + 15) \/ 16;\n    s->y_block_height = (s->frame_height + 15) \/ 16;\n    s->c_block_width = (s->frame_width \/ 4 + 15) \/ 16;\n    s->c_block_height = (s->frame_height \/ 4 + 15) \/ 16;\n    s->avctx= avctx;\n    s->m.avctx= avctx;\n    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));\n    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));\n    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));\n    h263_encode_init(&s->m); \n    return 0;\n}","25738":"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,\n                          int *end_pos2)\n{\n    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {\n        s->gb           = s->in_gb;\n        s->in_gb.buffer = NULL;\n        assert((get_bits_count(&s->gb) & 7) == 0);\n        skip_bits_long(&s->gb, *pos - *end_pos);\n        *end_pos2 =\n        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;\n        *pos      = get_bits_count(&s->gb);\n    }\n}","14639":"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n{\n    int16_t *block = ctx->dct_block;\n    unsigned int pos;\n    ctx->bdsp.clear_block(block);\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n    for (pos = 1; pos < num_coeffs; pos++) {\n        uint32_t vlc, num_bits;\n        int value;\n        int coeff;\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n        if (!vlc) \n            return 0;\n        if (vlc == -1)\n            return AVERROR_INVALIDDATA;\n        \n        pos     += vlc & 15; \n        num_bits = vlc >> 4; \n        if (pos >= 64)\n            return AVERROR_INVALIDDATA;\n        value = get_bits(&ctx->gb, num_bits);\n        \n        coeff = vlcdec_lookup[num_bits][value];\n        if (pos < 3)\n            coeff *= 16;\n        else \n            coeff = (coeff * qscale) \/ 1001;\n        block[ctx->scantable.permutated[pos]] = coeff;\n    }\n    return 0;\n}","25737":"static BufferPoolEntry *get_pool(AVBufferPool *pool)\n{\n    BufferPoolEntry *cur = NULL, *last = NULL;\n    do {\n        FFSWAP(BufferPoolEntry*, cur, last);\n        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);\n        if (!cur)\n            return NULL;\n    } while (cur != last);\n    return cur;\n}","24655":"static void test_function(const TestStruct test_sample)\n{\n    int ret, i;\n    void **output_data  = NULL;\n    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,\n                                            test_sample.nb_samples_pch);\n    if (!afifo) {\n        ERROR(\"ERROR: av_audio_fifo_alloc returned NULL!\");\n    }\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n    if (ret < 0){\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n    }\n    printf(\"written: %d\\n\", ret);\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n    if (ret < 0){\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n    }\n    printf(\"written: %d\\n\", ret);\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);\n    if (ret < 0){\n        ERROR(\"ERROR: av_audio_fifo_read failed!\");\n    }\n    printf(\"read: %d\\n\", ret);\n    print_audio_bytes(&test_sample, output_data, ret);\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n    \n    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);\n    if (ret < 0){\n        ERROR(\"ERROR: av_audio_fifo_peek failed!\");\n    }\n    printf(\"peek:\\n\");\n    print_audio_bytes(&test_sample, output_data, ret);\n    printf(\"\\n\");\n    \n    printf(\"peek_at:\\n\");\n    for (i = 0; i < afifo->nb_samples; ++i){\n        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n        if (ret < 0){\n            ERROR(\"ERROR: av_audio_fifo_peek_at failed!\");\n        }\n        printf(\"%d:\\n\", i);\n        print_audio_bytes(&test_sample, output_data, ret);\n    }\n    printf(\"\\n\");\n    \n    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);\n    if (ret < 0){\n        ERROR(\"ERROR: av_audio_fifo_drain failed!\");\n    }\n    if (afifo->nb_samples){\n        ERROR(\"drain failed to flush all samples in audio_fifo!\");\n    }\n    \n    for (i = 0; i < afifo->nb_buffers; ++i){\n        av_freep(&output_data[i]);\n    }\n    av_freep(&output_data);\n    av_audio_fifo_free(afifo);\n}","24424":"static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)\n{\n    IndividualChannelStream *ics = &sce->ics;\n    float *in    = sce->coeffs;\n    float *out   = sce->ret;\n    float *saved = sce->saved;\n    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;\n    float *buf  = ac->buf_mdct;\n    float *temp = ac->temp;\n    int i;\n    \n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)\n            av_log(ac->avctx, AV_LOG_WARNING,\n                   \"Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. \"\n                   \"If you heard an audible artifact, please submit the sample to the FFmpeg developers.\\n\");\n        for (i = 0; i < 1024; i += 128)\n            ff_imdct_half(&ac->mdct_small, buf + i, in + i);\n    } else\n        ff_imdct_half(&ac->mdct, buf, in);\n    \n    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&\n            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {\n        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);\n    } else {\n        for (i = 0; i < 448; i++)\n            out[i] = saved[i] + bias;\n        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);\n            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);\n            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);\n            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);\n            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);\n            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n        } else {\n            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n            for (i = 576; i < 1024; i++)\n                out[i] = buf[i-512] + bias;\n        }\n    }\n    \n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n        for (i = 0; i < 64; i++)\n            saved[i] = temp[64 + i] - bias;\n        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);\n        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);\n        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n        memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n    } else { \n        memcpy(                    saved,       buf + 512,        512 * sizeof(float));\n    }\n}","17932":"static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n    MpegEncContext * const s = &h->s;\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n    const int16_t (*l1mv1)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[1][b4_xy];\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n    const int8_t *l1ref1 = &h->ref_list[1][0].ref_index[1][b8_xy];\n    const int is_b8x8 = IS_8X8(*mb_type);\n    int sub_mb_type;\n    int i8, i4;\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n        \n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; \n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; \n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; \n    }else{\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; \n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n    }\n    if(!is_b8x8)\n        *mb_type |= MB_TYPE_DIRECT2;\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n    if(h->direct_spatial_mv_pred){\n        int ref[2];\n        int mv[2][2];\n        int list;\n        \n        for(list=0; list<2; list++){\n            int refa = h->ref_cache[list][scan8[0] - 1];\n            int refb = h->ref_cache[list][scan8[0] - 8];\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n            if(refc == -2)\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n            ref[list] = refa;\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n                ref[list] = refb;\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n                ref[list] = refc;\n            if(ref[list] < 0)\n                ref[list] = -1;\n        }\n        if(ref[0] < 0 && ref[1] < 0){\n            ref[0] = ref[1] = 0;\n            mv[0][0] = mv[0][1] =\n            mv[1][0] = mv[1][1] = 0;\n        }else{\n            for(list=0; list<2; list++){\n                if(ref[list] >= 0)\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n                else\n                    mv[list][0] = mv[list][1] = 0;\n            }\n        }\n        if(ref[1] < 0){\n            *mb_type &= ~MB_TYPE_P0L1;\n            sub_mb_type &= ~MB_TYPE_P0L1;\n        }else if(ref[0] < 0){\n            *mb_type &= ~MB_TYPE_P0L0;\n            sub_mb_type &= ~MB_TYPE_P0L0;\n        }\n        if(IS_16X16(*mb_type)){\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n            if(!IS_INTRA(mb_type_col)\n               && (   (l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1)\n                   || (l1ref0[0]  < 0 && l1ref1[0] == 0 && ABS(l1mv1[0][0]) <= 1 && ABS(l1mv1[0][1]) <= 1\n                       && (h->x264_build>33 || !h->x264_build)))){\n                if(ref[0] > 0)\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n                else\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n                if(ref[1] > 0)\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n                else\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n            }else{\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n            }\n        }else{\n            for(i8=0; i8<4; i8++){\n                const int x8 = i8&1;\n                const int y8 = i8>>1;\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n                    continue;\n                h->sub_mb_type[i8] = sub_mb_type;\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n                \n                if(!IS_INTRA(mb_type_col) && (   l1ref0[x8 + y8*h->b8_stride] == 0\n                                              || (l1ref0[x8 + y8*h->b8_stride] < 0 && l1ref1[x8 + y8*h->b8_stride] == 0\n                                                  && (h->x264_build>33 || !h->x264_build)))){\n                    const int16_t (*l1mv)[2]= l1ref0[x8 + y8*h->b8_stride] == 0 ? l1mv0 : l1mv1;\n                    for(i4=0; i4<4; i4++){\n                        const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n                            if(ref[0] == 0)\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n                            if(ref[1] == 0)\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }else{ \n        if(IS_16X16(*mb_type)){\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n            if(IS_INTRA(mb_type_col)){\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n            }else{\n                const int ref0 = l1ref0[0] >= 0 ? h->map_col_to_list0[0][l1ref0[0]]\n                                                : h->map_col_to_list0[1][l1ref1[0]];\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n                const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0];\n                int mv_l0[2];\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n            }\n        }else{\n            for(i8=0; i8<4; i8++){\n                const int x8 = i8&1;\n                const int y8 = i8>>1;\n                int ref0, dist_scale_factor;\n                const int16_t (*l1mv)[2]= l1mv0;\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n                    continue;\n                h->sub_mb_type[i8] = sub_mb_type;\n                if(IS_INTRA(mb_type_col)){\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n                    continue;\n                }\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n                if(ref0 >= 0)\n                    ref0 = h->map_col_to_list0[0][ref0];\n                else{\n                    ref0 = h->map_col_to_list0[1][l1ref1[x8 + y8*h->b8_stride]];\n                    l1mv= l1mv1;\n                }\n                dist_scale_factor = h->dist_scale_factor[ref0];\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n                for(i4=0; i4<4; i4++){\n                    const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n                }\n            }\n        }\n    }\n}","26435":"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n                                  const uint8_t *src, int srcW, int xInc)\n{\n    int i;\n    unsigned int xpos=0;\n    for (i=0;i<dstWidth;i++) {\n        register unsigned int xx=xpos>>16;\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n        xpos+=xInc;\n    }\n}","15115":"bool aio_poll(AioContext *ctx, bool blocking)\n{\n    AioHandler *node;\n    int i, ret;\n    bool progress;\n    int64_t timeout;\n    aio_context_acquire(ctx);\n    progress = false;\n    \n    if (blocking) {\n        atomic_add(&ctx->notify_me, 2);\n    }\n    ctx->walking_handlers++;\n    assert(npfd == 0);\n    \n    if (!aio_epoll_enabled(ctx)) {\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n            if (!node->deleted && node->pfd.events\n                && aio_node_check(ctx, node->is_external)) {\n                add_pollfd(node);\n            }\n        }\n    }\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n    \n    if (timeout) {\n        aio_context_release(ctx);\n    }\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n        AioHandler epoll_handler;\n        epoll_handler.pfd.fd = ctx->epollfd;\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n        npfd = 0;\n        add_pollfd(&epoll_handler);\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n    } else  {\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n    }\n    if (blocking) {\n        atomic_sub(&ctx->notify_me, 2);\n    }\n    if (timeout) {\n        aio_context_acquire(ctx);\n    }\n    aio_notify_accept(ctx);\n    \n    if (ret > 0) {\n        for (i = 0; i < npfd; i++) {\n            nodes[i]->pfd.revents = pollfds[i].revents;\n        }\n    }\n    npfd = 0;\n    ctx->walking_handlers--;\n    \n    if (aio_dispatch(ctx, ret > 0)) {\n        progress = true;\n    }\n    aio_context_release(ctx);\n    return progress;\n}","15999":"int hvf_vcpu_exec(CPUState *cpu)\n{\n    X86CPU *x86_cpu = X86_CPU(cpu);\n    CPUX86State *env = &x86_cpu->env;\n    int ret = 0;\n    uint64_t rip = 0;\n    cpu->halted = 0;\n    if (hvf_process_events(cpu)) {\n        return EXCP_HLT;\n    }\n    do {\n        if (cpu->vcpu_dirty) {\n            hvf_put_registers(cpu);\n            cpu->vcpu_dirty = false;\n        }\n        if (hvf_inject_interrupts(cpu)) {\n            return EXCP_INTERRUPT;\n        }\n        vmx_update_tpr(cpu);\n        qemu_mutex_unlock_iothread();\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n            qemu_mutex_lock_iothread();\n            return EXCP_HLT;\n        }\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n        assert_hvf_ok(r);\n        \n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n        hvf_store_events(cpu, ins_len, idtvec_info);\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n        env->eflags = RFLAGS(env);\n        qemu_mutex_lock_iothread();\n        update_apic_tpr(cpu);\n        current_cpu = cpu;\n        ret = 0;\n        switch (exit_reason) {\n        case EXIT_REASON_HLT: {\n            macvm_set_rip(cpu, rip + ins_len);\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n                (EFLAGS(env) & IF_MASK))\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n                cpu->halted = 1;\n                ret = EXCP_HLT;\n            }\n            ret = EXCP_INTERRUPT;\n            break;\n        }\n        case EXIT_REASON_MWAIT: {\n            ret = EXCP_INTERRUPT;\n            break;\n        }\n            \n        case EXIT_REASON_EPT_FAULT:\n        {\n            hvf_slot *slot;\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n                vmx_set_nmi_blocking(cpu);\n            }\n            slot = hvf_find_overlap_slot(gpa, gpa);\n            \n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n                struct x86_decode decode;\n                load_regs(cpu);\n                env->hvf_emul->fetch_rip = rip;\n                decode_instruction(env, &decode);\n                exec_instruction(env, &decode);\n                store_regs(cpu);\n                break;\n            }\n            break;\n        }\n        case EXIT_REASON_INOUT:\n        {\n            uint32_t in = (exit_qual & 8) != 0;\n            uint32_t size =  (exit_qual & 7) + 1;\n            uint32_t string =  (exit_qual & 16) != 0;\n            uint32_t port =  exit_qual >> 16;\n            \n#if 1\n            if (!string && in) {\n                uint64_t val = 0;\n                load_regs(cpu);\n                hvf_handle_io(env, port, &val, 0, size, 1);\n                if (size == 1) {\n                    AL(env) = val;\n                } else if (size == 2) {\n                    AX(env) = val;\n                } else if (size == 4) {\n                    RAX(env) = (uint32_t)val;\n                } else {\n                    VM_PANIC(\"size\");\n                }\n                RIP(env) += ins_len;\n                store_regs(cpu);\n                break;\n            } else if (!string && !in) {\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n                macvm_set_rip(cpu, rip + ins_len);\n                break;\n            }\n#endif\n            struct x86_decode decode;\n            load_regs(cpu);\n            env->hvf_emul->fetch_rip = rip;\n            decode_instruction(env, &decode);\n            VM_PANIC_ON(ins_len != decode.len);\n            exec_instruction(env, &decode);\n            store_regs(cpu);\n            break;\n        }\n        case EXIT_REASON_CPUID: {\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n            macvm_set_rip(cpu, rip + ins_len);\n            break;\n        }\n        case EXIT_REASON_XSETBV: {\n            X86CPU *x86_cpu = X86_CPU(cpu);\n            CPUX86State *env = &x86_cpu->env;\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n            if (ecx) {\n                macvm_set_rip(cpu, rip + ins_len);\n                break;\n            }\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n            macvm_set_rip(cpu, rip + ins_len);\n            break;\n        }\n        case EXIT_REASON_INTR_WINDOW:\n            vmx_clear_int_window_exiting(cpu);\n            ret = EXCP_INTERRUPT;\n            break;\n        case EXIT_REASON_NMI_WINDOW:\n            vmx_clear_nmi_window_exiting(cpu);\n            ret = EXCP_INTERRUPT;\n            break;\n        case EXIT_REASON_EXT_INTR:\n            \n            ret = EXCP_INTERRUPT;\n            break;\n        case EXIT_REASON_RDMSR:\n        case EXIT_REASON_WRMSR:\n        {\n            load_regs(cpu);\n            if (exit_reason == EXIT_REASON_RDMSR) {\n                simulate_rdmsr(cpu);\n            } else {\n                simulate_wrmsr(cpu);\n            }\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n            store_regs(cpu);\n            break;\n        }\n        case EXIT_REASON_CR_ACCESS: {\n            int cr;\n            int reg;\n            load_regs(cpu);\n            cr = exit_qual & 15;\n            reg = (exit_qual >> 8) & 15;\n            switch (cr) {\n            case 0x0: {\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n                break;\n            }\n            case 4: {\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n                break;\n            }\n            case 8: {\n                X86CPU *x86_cpu = X86_CPU(cpu);\n                if (exit_qual & 0x10) {\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n                } else {\n                    int tpr = RRX(env, reg);\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n                    ret = EXCP_INTERRUPT;\n                }\n                break;\n            }\n            default:\n                error_report(\"Unrecognized CR %d\\n\", cr);\n                abort();\n            }\n            RIP(env) += ins_len;\n            store_regs(cpu);\n            break;\n        }\n        case EXIT_REASON_APIC_ACCESS: { \n            struct x86_decode decode;\n            load_regs(cpu);\n            env->hvf_emul->fetch_rip = rip;\n            decode_instruction(env, &decode);\n            exec_instruction(env, &decode);\n            store_regs(cpu);\n            break;\n        }\n        case EXIT_REASON_TPR: {\n            ret = 1;\n            break;\n        }\n        case EXIT_REASON_TASK_SWITCH: {\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n             & VMCS_INTR_T_MASK);\n            break;\n        }\n        case EXIT_REASON_TRIPLE_FAULT: {\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n            ret = EXCP_INTERRUPT;\n            break;\n        }\n        case EXIT_REASON_RDPMC:\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n            macvm_set_rip(cpu, rip + ins_len);\n            break;\n        case VMX_REASON_VMCALL:\n            \n            break;\n        default:\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n        }\n    } while (ret == 0);\n    return ret;\n}","18175":"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n                            AVPacket *avpkt)\n{\n    const char *ptr = avpkt->data;\n    int len, size = avpkt->size;\n    while (size > 0) {\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n        int duration = dialog->end - dialog->start;\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n        if (len < 0)\n            return len;\n        ptr  += len;\n        size -= len;\n    }\n    *got_sub_ptr = avpkt->size > 0;\n    return avpkt->size;\n}","21050":"void show_help(void)\n{\n    const char *prog;\n    const OptionDef *po;\n    int i, expert;\n    \n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n           prog);\n    \n    if (!do_play) {\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n               \"Hyper fast MPEG1\/MPEG4\/H263\/RV and AC3\/MPEG audio encoder\\n\");\n    } else {\n        printf(\"usage: ffplay [options] input_file...\\n\"\n               \"Simple audio player\\n\");\n    }\n           \n    printf(\"\\n\"\n           \"Main options are:\\n\");\n    for(i=0;i<2;i++) {\n        if (i == 1)\n            printf(\"\\nAdvanced options are:\\n\");\n        for(po = options; po->name != NULL; po++) {\n            char buf[64];\n            expert = (po->flags & OPT_EXPERT) != 0;\n            if (expert == i) {\n                strcpy(buf, po->name);\n                if (po->flags & HAS_ARG) {\n                    strcat(buf, \" \");\n                    strcat(buf, po->argname);\n                }\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n            }\n        }\n    }\n    exit(1);\n}","8130":"static void device_unparent(Object *obj)\n{\n    DeviceState *dev = DEVICE(obj);\n    BusState *bus;\n    if (dev->realized) {\n        object_property_set_bool(obj, false, \"realized\", NULL);\n    }\n    while (dev->num_child_bus) {\n        bus = QLIST_FIRST(&dev->child_bus);\n        object_unparent(OBJECT(bus));\n    }\n    if (dev->parent_bus) {\n        bus_remove_child(dev->parent_bus, dev);\n        object_unref(OBJECT(dev->parent_bus));\n        dev->parent_bus = NULL;\n    }\n    \n    if (dev->pending_deleted_event) {\n        g_assert(dev->canonical_path);\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n                                       &error_abort);\n        g_free(dev->canonical_path);\n        dev->canonical_path = NULL;\n    }\n}","13311":"static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int block_num)\n{\n    MpegEncContext *s  = &v->s;\n    int mb_cbp         = v->cbp[s->mb_x - 1 - s->mb_stride],\n        block_cbp      = mb_cbp      >> (block_num * 4), right_cbp,\n        mb_is_intra    = v->is_intra[s->mb_x - 1 - s->mb_stride],\n        block_is_intra = mb_is_intra >> (block_num * 4), right_is_intra;\n    int idx, linesize  = block_num > 3 ? s->uvlinesize : s->linesize, ttblk;\n    uint8_t *dst;\n    if (block_num > 3) {\n        dst = s->dest[block_num - 3] - 8 * linesize;\n    } else {\n        dst = s->dest[0] + (block_num & 1) * 8 + ((block_num & 2) * 4 - 16) * linesize - 8;\n    }\n    if (s->mb_x != s->mb_width || !(block_num & 5)) {\n        int16_t (*mv)[2];\n        if (block_num > 3) {\n            right_cbp      = v->cbp[s->mb_x - s->mb_stride] >> (block_num * 4);\n            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);\n            mv             = &v->luma_mv[s->mb_x - s->mb_stride - 1];\n        } else {\n            right_cbp      = (block_num & 1) ? (v->cbp[s->mb_x - s->mb_stride]      >> ((block_num - 1) * 4))\n                                             : (mb_cbp                              >> ((block_num + 1) * 4));\n            right_is_intra = (block_num & 1) ? (v->is_intra[s->mb_x - s->mb_stride] >> ((block_num - 1) * 4))\n                                             : (mb_is_intra                         >> ((block_num + 1) * 4));\n            mv             = &s->current_picture.motion_val[0][s->block_index[block_num] - s->b8_stride * 2 - 2];\n        }\n        if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) {\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n        } else {\n            idx = ((right_cbp >> 1) | block_cbp) & 5; \n            if (idx == 5) {\n                v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n            } else if (idx) {\n                if (idx == 1)\n                    v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq);\n                else\n                    v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n            }\n        }\n    }\n    dst -= 4;\n    ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> (block_num * 4)) & 0xf;\n    if (ttblk == TT_4X4 || ttblk == TT_4X8) {\n        idx = (block_cbp | (block_cbp >> 1)) & 5;\n        if (idx == 5) {\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n        } else if (idx) {\n            if (idx == 1)\n                v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq);\n            else\n                v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n        }\n    }\n}","5508":"static int connect_namedsocket(const char *path)\n{\n    int sockfd, size;\n    struct sockaddr_un helper;\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n        return -1;\n    }\n    strcpy(helper.sun_path, path);\n    helper.sun_family = AF_UNIX;\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n        fprintf(stderr, \"socket error\\n\");\n        return -1;\n    }\n    \n    unlink(path);\n    return sockfd;\n}","4362":"static int vmdk_open_vmdk4(BlockDriverState *bs,\n                           BlockDriverState *file,\n                           int flags)\n{\n    int ret;\n    uint32_t magic;\n    uint32_t l1_size, l1_entry_sectors;\n    VMDK4Header header;\n    VmdkExtent *extent;\n    int64_t l1_backup_offset = 0;\n    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));\n    if (ret < 0) {\n        return ret;\n    }\n    if (header.capacity == 0) {\n        int64_t desc_offset = le64_to_cpu(header.desc_offset);\n        if (desc_offset) {\n            return vmdk_open_desc_file(bs, flags, desc_offset << 9);\n        }\n    }\n    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {\n        \n        struct {\n            struct {\n                uint64_t val;\n                uint32_t size;\n                uint32_t type;\n                uint8_t pad[512 - 16];\n            } QEMU_PACKED footer_marker;\n            uint32_t magic;\n            VMDK4Header header;\n            uint8_t pad[512 - 4 - sizeof(VMDK4Header)];\n            struct {\n                uint64_t val;\n                uint32_t size;\n                uint32_t type;\n                uint8_t pad[512 - 16];\n            } QEMU_PACKED eos_marker;\n        } QEMU_PACKED footer;\n        ret = bdrv_pread(file,\n            bs->file->total_sectors * 512 - 1536,\n            &footer, sizeof(footer));\n        if (ret < 0) {\n            return ret;\n        }\n        \n        if (be32_to_cpu(footer.magic) != VMDK4_MAGIC ||\n            le32_to_cpu(footer.footer_marker.size) != 0  ||\n            le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER ||\n            le64_to_cpu(footer.eos_marker.val) != 0  ||\n            le32_to_cpu(footer.eos_marker.size) != 0  ||\n            le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM)\n        {\n            return -EINVAL;\n        }\n        header = footer.header;\n    }\n    if (le32_to_cpu(header.version) >= 3) {\n        char buf[64];\n        snprintf(buf, sizeof(buf), \"VMDK version %d\",\n                 le32_to_cpu(header.version));\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n                bs->device_name, \"vmdk\", buf);\n        return -ENOTSUP;\n    }\n    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)\n                        * le64_to_cpu(header.granularity);\n    if (l1_entry_sectors == 0) {\n        return -EINVAL;\n    }\n    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)\n                \/ l1_entry_sectors;\n    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {\n        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;\n    }\n    extent = vmdk_add_extent(bs, file, false,\n                          le64_to_cpu(header.capacity),\n                          le64_to_cpu(header.gd_offset) << 9,\n                          l1_backup_offset,\n                          l1_size,\n                          le32_to_cpu(header.num_gtes_per_gte),\n                          le64_to_cpu(header.granularity));\n    extent->compressed =\n        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;\n    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;\n    extent->version = le32_to_cpu(header.version);\n    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;\n    ret = vmdk_init_tables(bs, extent);\n    if (ret) {\n        \n        vmdk_free_last_extent(bs);\n    }\n    return ret;\n}","2329":"static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n                           stellaris_board_info *board)\n{\n    static const int uart_irq[] = {5, 6, 33, 34};\n    static const int timer_irq[] = {19, 21, 23, 35};\n    static const uint32_t gpio_addr[7] =\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n        0x40024000, 0x40025000, 0x40026000};\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n    qemu_irq *pic;\n    DeviceState *gpio_dev[7];\n    qemu_irq gpio_in[7][8];\n    qemu_irq gpio_out[7][8];\n    qemu_irq adc;\n    int sram_size;\n    int flash_size;\n    I2CBus *i2c;\n    DeviceState *dev;\n    int i;\n    int j;\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n    MemoryRegion *system_memory = get_system_memory();\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n    \n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n                           &error_abort);\n    vmstate_register_ram_global(flash);\n    memory_region_set_readonly(flash, true);\n    memory_region_add_subregion(system_memory, 0, flash);\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n                           &error_abort);\n    vmstate_register_ram_global(sram);\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n                      kernel_filename, cpu_model);\n    if (board->dc1 & (1 << 16)) {\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n        adc = qdev_get_gpio_in(dev, 0);\n    } else {\n        adc = NULL;\n    }\n    for (i = 0; i < 4; i++) {\n        if (board->dc2 & (0x10000 << i)) {\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n                                       0x40030000 + i * 0x1000,\n                                       pic[timer_irq[i]]);\n            \n            qdev_connect_gpio_out(dev, 0, adc);\n        }\n    }\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n    for (i = 0; i < 7; i++) {\n        if (board->dc4 & (1 << i)) {\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n                                               pic[gpio_irq[i]]);\n            for (j = 0; j < 8; j++) {\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n                gpio_out[i][j] = NULL;\n            }\n        }\n    }\n    if (board->dc2 & (1 << 12)) {\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n        if (board->peripherals & BP_OLED_I2C) {\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n        }\n    }\n    for (i = 0; i < 4; i++) {\n        if (board->dc2 & (1 << i)) {\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n                                 pic[uart_irq[i]]);\n        }\n    }\n    if (board->dc2 & (1 << 4)) {\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n        if (board->peripherals & BP_OLED_SSI) {\n            void *bus;\n            DeviceState *sddev;\n            DeviceState *ssddev;\n            \n            bus = qdev_get_child_bus(dev, \"ssi\");\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n            \n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n        }\n    }\n    if (board->dc4 & (1 << 28)) {\n        DeviceState *enet;\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n        enet = qdev_create(NULL, \"stellaris_enet\");\n        qdev_set_nic_properties(enet, &nd_table[0]);\n        qdev_init_nofail(enet);\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n    }\n    if (board->peripherals & BP_GAMEPAD) {\n        qemu_irq gpad_irq[5];\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); \n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); \n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); \n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); \n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); \n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n    }\n    for (i = 0; i < 7; i++) {\n        if (board->dc4 & (1 << i)) {\n            for (j = 0; j < 8; j++) {\n                if (gpio_out[i][j]) {\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n                }\n            }\n        }\n    }\n}","4006":"static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n                                 bool query_backing)\n{\n    BlockStats *s = NULL;\n    s = g_malloc0(sizeof(*s));\n    s->stats = g_malloc0(sizeof(*s->stats));\n    if (!bs) {\n        return s;\n    }\n    if (bdrv_get_node_name(bs)[0]) {\n        s->has_node_name = true;\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n    }\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n    if (bs->file) {\n        s->has_parent = true;\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n    }\n    if (query_backing && bs->backing) {\n        s->has_backing = true;\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n    }\n    return s;\n}","1338":"static void sd_1d97_int(int *p, int i0, int i1)\n{\n    int i;\n    if (i1 <= i0 + 1) {\n        if (i0 == 1)\n            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;\n        else\n            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;\n        return;\n    }\n    extend97_int(p, i0, i1);\n    i0++; i1++;\n    for (i = i0\/2 - 2; i < i1\/2 + 1; i++)\n        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n    for (i = i0\/2 - 1; i < i1\/2 + 1; i++)\n        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n    for (i = i0\/2 - 1; i < i1\/2; i++)\n        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n    for (i = i0\/2; i < i1\/2; i++)\n        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n}","14814":"static inline TCGv iwmmxt_load_creg(int reg)\n{\n    TCGv var = new_tmp();\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n    return var;\n}","25602":"static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n{\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n    int ret = 0;\n    if (!s->config)\n        goto fail;\n    switch (p->pid) {\n    case USB_TOKEN_IN:\n        switch (p->devep & 0xf) {\n        case USB_EVT_EP:\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n            break;\n        case USB_ACL_EP:\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n            break;\n        case USB_SCO_EP:\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n            break;\n        default:\n            goto fail;\n        }\n        break;\n    case USB_TOKEN_OUT:\n        switch (p->devep & 0xf) {\n        case USB_ACL_EP:\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n                            usb_bt_hci_acl_complete, p->data, p->len);\n            break;\n        case USB_SCO_EP:\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n                            usb_bt_hci_sco_complete, p->data, p->len);\n            break;\n        default:\n            goto fail;\n        }\n        break;\n    default:\n    fail:\n        ret = USB_RET_STALL;\n        break;\n    }\n    return ret;\n}","27148":"static void pci_hotplug(void)\n{\n    QVirtioPCIDevice *dev;\n    QOSState *qs;\n    const char *arch = qtest_get_arch();\n    qs = pci_test_start();\n    \n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n                          \"'drive': 'drive1'\");\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n    g_assert(dev);\n    qvirtio_pci_device_disable(dev);\n    g_free(dev);\n    \n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n    }\n    qtest_shutdown(qs);\n}","19908":"int ff_wma_init(AVCodecContext *avctx, int flags2)\n{\n    WMACodecContext *s = avctx->priv_data;\n    int i;\n    float bps1, high_freq;\n    volatile float bps;\n    int sample_rate1;\n    int coef_vlc_table;\n    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000\n        || avctx->channels    <= 0 || avctx->channels    > 2\n        || avctx->bit_rate    <= 0)\n        return -1;\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n        s->version = 1;\n    } else {\n        s->version = 2;\n    \n    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,\n                                                  s->version, 0);\n    s->next_block_len_bits = s->frame_len_bits;\n    s->prev_block_len_bits = s->frame_len_bits;\n    s->block_len_bits      = s->frame_len_bits;\n    s->frame_len = 1 << s->frame_len_bits;\n    if (s->use_variable_block_len) {\n        int nb_max, nb;\n        nb = ((flags2 >> 3) & 3) + 1;\n        if ((avctx->bit_rate \/ avctx->channels) >= 32000)\n            nb += 2;\n        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;\n        if (nb > nb_max)\n            nb = nb_max;\n        s->nb_block_sizes = nb + 1;\n    } else {\n        s->nb_block_sizes = 1;\n    \n    s->use_noise_coding = 1;\n    high_freq = avctx->sample_rate * 0.5;\n    \n    sample_rate1 = avctx->sample_rate;\n    if (s->version == 2) {\n        if (sample_rate1 >= 44100) {\n            sample_rate1 = 44100;\n        } else if (sample_rate1 >= 22050) {\n            sample_rate1 = 22050;\n        } else if (sample_rate1 >= 16000) {\n            sample_rate1 = 16000;\n        } else if (sample_rate1 >= 11025) {\n            sample_rate1 = 11025;\n        } else if (sample_rate1 >= 8000) {\n            sample_rate1 = 8000;\n    bps = (float)avctx->bit_rate \/ (float)(avctx->channels * avctx->sample_rate);\n    s->byte_offset_bits = av_log2((int)(bps * s->frame_len \/ 8.0 + 0.5)) + 2;\n    \n    bps1 = bps;\n    if (avctx->channels == 2)\n        bps1 = bps * 1.6;\n    if (sample_rate1 == 44100) {\n        if (bps1 >= 0.61) {\n            s->use_noise_coding = 0;\n        } else {\n            high_freq = high_freq * 0.4;\n    } else if (sample_rate1 == 22050) {\n        if (bps1 >= 1.16) {\n            s->use_noise_coding = 0;\n        } else if (bps1 >= 0.72) {\n            high_freq = high_freq * 0.7;\n        } else {\n            high_freq = high_freq * 0.6;\n    } else if (sample_rate1 == 16000) {\n        if (bps > 0.5) {\n            high_freq = high_freq * 0.5;\n        } else {\n            high_freq = high_freq * 0.3;\n    } else if (sample_rate1 == 11025) {\n        high_freq = high_freq * 0.7;\n    } else if (sample_rate1 == 8000) {\n        if (bps <= 0.625) {\n            high_freq = high_freq * 0.5;\n        } else if (bps > 0.75) {\n            s->use_noise_coding = 0;\n        } else {\n            high_freq = high_freq * 0.65;\n    } else {\n        if (bps >= 0.8) {\n            high_freq = high_freq * 0.75;\n        } else if (bps >= 0.6) {\n            high_freq = high_freq * 0.6;\n        } else {\n            high_freq = high_freq * 0.5;\n    av_dlog(s->avctx, \"flags2=0x%x\\n\", flags2);\n    av_dlog(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",\n            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,\n            avctx->block_align);\n    av_dlog(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",\n            bps, bps1, high_freq, s->byte_offset_bits);\n    av_dlog(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",\n            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);\n    \n    {\n        int a, b, pos, lpos, k, block_len, i, j, n;\n        const uint8_t *table;\n        if (s->version == 1) {\n            s->coefs_start = 3;\n        } else {\n            s->coefs_start = 0;\n        for (k = 0; k < s->nb_block_sizes; k++) {\n            block_len = s->frame_len >> k;\n            if (s->version == 1) {\n                lpos = 0;\n                for (i = 0; i < 25; i++) {\n                    a = ff_wma_critical_freqs[i];\n                    b = avctx->sample_rate;\n                    pos = ((block_len * 2 * a) + (b >> 1)) \/ b;\n                    if (pos > block_len)\n                        pos = block_len;\n                    s->exponent_bands[0][i] = pos - lpos;\n                    if (pos >= block_len) {\n                        i++;\n                        break;\n                    lpos = pos;\n                s->exponent_sizes[0] = i;\n            } else {\n                \n                table = NULL;\n                a = s->frame_len_bits - BLOCK_MIN_BITS - k;\n                if (a < 3) {\n                    if (avctx->sample_rate >= 44100) {\n                        table = exponent_band_44100[a];\n                    } else if (avctx->sample_rate >= 32000) {\n                        table = exponent_band_32000[a];\n                    } else if (avctx->sample_rate >= 22050) {\n                        table = exponent_band_22050[a];\n                if (table) {\n                    n = *table++;\n                    for (i = 0; i < n; i++)\n                        s->exponent_bands[k][i] = table[i];\n                    s->exponent_sizes[k] = n;\n                } else {\n                    j = 0;\n                    lpos = 0;\n                    for (i = 0; i < 25; i++) {\n                        a = ff_wma_critical_freqs[i];\n                        b = avctx->sample_rate;\n                        pos = ((block_len * 2 * a) + (b << 1)) \/ (4 * b);\n                        pos <<= 2;\n                        if (pos > block_len)\n                            pos = block_len;\n                        if (pos > lpos)\n                            s->exponent_bands[k][j++] = pos - lpos;\n                        if (pos >= block_len)\n                            break;\n                        lpos = pos;\n                    s->exponent_sizes[k] = j;\n            \n            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) \/ 100)) >> k;\n            \n            s->high_band_start[k] = (int)((block_len * 2 * high_freq) \/\n                                          avctx->sample_rate + 0.5);\n            n = s->exponent_sizes[k];\n            j = 0;\n            pos = 0;\n            for (i = 0; i < n; i++) {\n                int start, end;\n                start = pos;\n                pos += s->exponent_bands[k][i];\n                end = pos;\n                if (start < s->high_band_start[k])\n                    start = s->high_band_start[k];\n                if (end > s->coefs_end[k])\n                    end = s->coefs_end[k];\n                if (end > start)\n                    s->exponent_high_bands[k][j++] = end - start;\n            s->exponent_high_sizes[k] = j;\n#if 0\n            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",\n                    s->frame_len >> k,\n                    s->coefs_end[k],\n                    s->high_band_start[k],\n                    s->exponent_high_sizes[k]);\n            for (j = 0; j < s->exponent_high_sizes[k]; j++)\n                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);\n            tprintf(s->avctx, \"\\n\");\n#endif\n#ifdef TRACE\n    {\n        int i, j;\n        for (i = 0; i < s->nb_block_sizes; i++) {\n            tprintf(s->avctx, \"%5d: n=%2d:\",\n                    s->frame_len >> i,\n                    s->exponent_sizes[i]);\n            for (j = 0; j < s->exponent_sizes[i]; j++)\n                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);\n            tprintf(s->avctx, \"\\n\");\n#endif\n    \n    for (i = 0; i < s->nb_block_sizes; i++) {\n        ff_init_ff_sine_windows(s->frame_len_bits - i);\n        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];\n    s->reset_block_lengths = 1;\n    if (s->use_noise_coding) {\n        \n        if (s->use_exp_vlc) {\n            s->noise_mult = 0.02;\n        } else {\n            s->noise_mult = 0.04;\n#ifdef TRACE\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n            s->noise_table[i] = 1.0 * s->noise_mult;\n#else\n        {\n            unsigned int seed;\n            float norm;\n            seed = 1;\n            norm = (1.0 \/ (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n                seed = seed * 314159 + 1;\n                s->noise_table[i] = (float)((int)seed) * norm;\n#endif\n    \n    coef_vlc_table = 2;\n    if (avctx->sample_rate >= 32000) {\n        if (bps1 < 0.72) {\n            coef_vlc_table = 0;\n        } else if (bps1 < 1.16) {\n            coef_vlc_table = 1;\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n                  s->coef_vlcs[0]);\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n                  s->coef_vlcs[1]);\n    return 0;","22976":"static av_cold int vp3_decode_end(AVCodecContext *avctx)\n{\n    Vp3DecodeContext *s = avctx->priv_data;\n    int i;\n    if (avctx->is_copy && !s->current_frame.data[0])\n        return 0;\n    av_free(s->superblock_coding);\n    av_free(s->all_fragments);\n    av_free(s->coded_fragment_list[0]);\n    av_free(s->dct_tokens_base);\n    av_free(s->superblock_fragments);\n    av_free(s->macroblock_coding);\n    av_free(s->motion_val[0]);\n    av_free(s->motion_val[1]);\n    av_free(s->edge_emu_buffer);\n    if (avctx->is_copy) return 0;\n    for (i = 0; i < 16; i++) {\n        free_vlc(&s->dc_vlc[i]);\n        free_vlc(&s->ac_vlc_1[i]);\n        free_vlc(&s->ac_vlc_2[i]);\n        free_vlc(&s->ac_vlc_3[i]);\n        free_vlc(&s->ac_vlc_4[i]);\n    }\n    free_vlc(&s->superblock_run_length_vlc);\n    free_vlc(&s->fragment_run_length_vlc);\n    free_vlc(&s->mode_code_vlc);\n    free_vlc(&s->motion_vector_vlc);\n    \n    if (s->golden_frame.data[0])\n        ff_thread_release_buffer(avctx, &s->golden_frame);\n    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)\n        ff_thread_release_buffer(avctx, &s->last_frame);\n    \n    return 0;\n}","18640":"static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n{\n    NE2000State *s = opaque;\n    int offset, page;\n    addr &= 0xf;\n#ifdef DEBUG_NE2000\n    printf(\"NE2000: write addr=0x%x val=0x%02x\\n\", addr, val);\n#endif\n    if (addr == E8390_CMD) {\n        \n        s->cmd = val;\n        if (val & E8390_START) {\n            s->isr &= ~ENISR_RESET;\n            \n            if ((val & (E8390_RREAD | E8390_RWRITE)) &&\n                s->rcnt == 0) {\n                s->isr |= ENISR_RDC;\n                ne2000_update_irq(s);\n            }\n            if (val & E8390_TRANS) {\n                qemu_send_packet(s->nd, s->mem + (s->tpsr << 8), s->tcnt);\n                \n                s->tsr = ENTSR_PTX;\n                s->isr |= ENISR_TX;\n                ne2000_update_irq(s);\n            }\n        }\n    } else {\n        page = s->cmd >> 6;\n        offset = addr | (page << 4);\n        switch(offset) {\n        case EN0_STARTPG:\n            s->start = val << 8;\n            break;\n        case EN0_STOPPG:\n            s->stop = val << 8;\n            break;\n        case EN0_BOUNDARY:\n            s->boundary = val;\n            break;\n        case EN0_IMR:\n            s->imr = val;\n            ne2000_update_irq(s);\n            break;\n        case EN0_TPSR:\n            s->tpsr = val;\n            break;\n        case EN0_TCNTLO:\n            s->tcnt = (s->tcnt & 0xff00) | val;\n            break;\n        case EN0_TCNTHI:\n            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);\n            break;\n        case EN0_RSARLO:\n            s->rsar = (s->rsar & 0xff00) | val;\n            break;\n        case EN0_RSARHI:\n            s->rsar = (s->rsar & 0x00ff) | (val << 8);\n            break;\n        case EN0_RCNTLO:\n            s->rcnt = (s->rcnt & 0xff00) | val;\n            break;\n        case EN0_RCNTHI:\n            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);\n            break;\n        case EN0_DCFG:\n            s->dcfg = val;\n            break;\n        case EN0_ISR:\n            s->isr &= ~(val & 0x7f);\n            ne2000_update_irq(s);\n            break;\n        case EN1_PHYS ... EN1_PHYS + 5:\n            s->phys[offset - EN1_PHYS] = val;\n            break;\n        case EN1_CURPAG:\n            s->curpag = val;\n            break;\n        case EN1_MULT ... EN1_MULT + 7:\n            s->mult[offset - EN1_MULT] = val;\n            break;\n        }\n    }\n}","22955":"static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n{\n    int i;\n    int32_t *dst = (int32_t *) _dst;\n    for (i = 0; i < width; i++)\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n}","17737":"int swr_init(struct SwrContext *s){\n    s->in_buffer_index= 0;\n    s->in_buffer_count= 0;\n    s->resample_in_constraint= 0;\n    free_temp(&s->postin);\n    free_temp(&s->midbuf);\n    free_temp(&s->preout);\n    free_temp(&s->in_buffer);\n    swri_audio_convert_free(&s-> in_convert);\n    swri_audio_convert_free(&s->out_convert);\n    swri_audio_convert_free(&s->full_convert);\n    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);\n    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);\n    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);\n    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->in_sample_fmt));\n        return AVERROR(EINVAL);\n    }\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->out_sample_fmt));\n        return AVERROR(EINVAL);\n    }\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n        return AVERROR(EINVAL);\n    }\n    \n    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16;\n    }else\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);\n    }else\n        swri_resample_free(&s->resample);\n    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16 currently\\n\"); \n        return -1;\n    }\n    if(!s->used_ch_count)\n        s->used_ch_count= s->in.ch_count;\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n        s-> in_ch_layout= 0;\n    }\n    if(!s-> in_ch_layout)\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n    if(!s->out_ch_layout)\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0;\n#define RSC 1 \n    if(!s-> in.ch_count)\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n    if(!s->used_ch_count)\n        s->used_ch_count= s->in.ch_count;\n    if(!s->out.ch_count)\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\nav_assert0(s-> in.ch_count);\nav_assert0(s->used_ch_count);\nav_assert0(s->out.ch_count);\n    s->resample_first= RSC*s->out.ch_count\/s->in.ch_count - RSC < s->out_sample_rate\/(float)s-> in_sample_rate - 1.0;\n    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);\n    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);\n    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);\n    if(!s->resample && !s->rematrix && !s->channel_map){\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n        return 0;\n    }\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n    s->postin= s->in;\n    s->preout= s->out;\n    s->midbuf= s->in;\n    s->in_buffer= s->in;\n    if(s->channel_map){\n        s->postin.ch_count=\n        s->midbuf.ch_count=\n        s->in_buffer.ch_count= s->used_ch_count;\n    }\n    if(!s->resample_first){\n        s->midbuf.ch_count= s->out.ch_count;\n        s->in_buffer.ch_count = s->out.ch_count;\n    }\n    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;\n    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;\n    if(s->rematrix)\n        return swri_rematrix_init(s);\n    return 0;\n}","1937":"static int rtsp_listen(AVFormatContext *s)\n{\n    RTSPState *rt = s->priv_data;\n    char proto[128], host[128], path[512], auth[128];\n    char uri[500];\n    int port;\n    int default_port = RTSP_DEFAULT_PORT;\n    char tcpname[500];\n    const char *lower_proto = \"tcp\";\n    unsigned char rbuf[4096];\n    unsigned char method[10];\n    int rbuflen = 0;\n    int ret;\n    enum RTSPMethod methodcode;\n    if (!rt->protocols) {\n        rt->protocols = ffurl_get_protocols(NULL, NULL);\n        if (!rt->protocols)\n            return AVERROR(ENOMEM);\n    }\n    \n    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),\n                 &port, path, sizeof(path), s->filename);\n    \n    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,\n                port, \"%s\", path);\n    if (!strcmp(proto, \"rtsps\")) {\n        lower_proto  = \"tls\";\n        default_port = RTSPS_DEFAULT_PORT;\n    }\n    if (port < 0)\n        port = default_port;\n    \n    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,\n                \"?listen&listen_timeout=%d\", rt->initial_timeout * 1000);\n    if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE,\n                         &s->interrupt_callback, NULL, rt->protocols)) {\n        av_log(s, AV_LOG_ERROR, \"Unable to open RTSP for listening\\n\");\n        return ret;\n    }\n    rt->state       = RTSP_STATE_IDLE;\n    rt->rtsp_hd_out = rt->rtsp_hd;\n    for (;;) { \n        ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen);\n        if (ret < 0)\n            return ret;\n        ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method,\n                                 sizeof(method), &methodcode);\n        if (ret) {\n            av_log(s, AV_LOG_ERROR, \"RTSP: Unexpected Command\\n\");\n            return ret;\n        }\n        if (methodcode == ANNOUNCE) {\n            ret       = rtsp_read_announce(s);\n            rt->state = RTSP_STATE_PAUSED;\n        } else if (methodcode == OPTIONS) {\n            ret = rtsp_read_options(s);\n        } else if (methodcode == RECORD) {\n            ret = rtsp_read_record(s);\n            if (!ret)\n                return 0; \n        } else if (methodcode == SETUP)\n            ret = rtsp_read_setup(s, host, uri);\n        if (ret) {\n            ffurl_close(rt->rtsp_hd);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    return 0;\n}","2451":"static int net_vhost_user_init(NetClientState *peer, const char *device,\n                               const char *name, CharDriverState *chr,\n                               int queues)\n{\n    NetClientState *nc;\n    VhostUserState *s;\n    int i;\n    for (i = 0; i < queues; i++) {\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n                 i, chr->label);\n        nc->queue_index = i;\n        s = DO_UPCAST(VhostUserState, nc, nc);\n        s->chr = chr;\n    }\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n    return 0;\n}","21750":"static int swf_write_trailer(AVFormatContext *s)\n{\n    SWFContext *swf = s->priv_data;\n    ByteIOContext *pb = &s->pb;\n    AVCodecContext *enc, *video_enc;\n    int file_size, i;\n    video_enc = NULL;\n    for(i=0;i<s->nb_streams;i++) {\n        enc = &s->streams[i]->codec;\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n            video_enc = enc;\n    }\n    put_swf_tag(s, TAG_END);\n    put_swf_end_tag(s);\n    \n    put_flush_packet(&s->pb);\n    \n    if (!url_is_streamed(&s->pb) && video_enc) {\n        file_size = url_ftell(pb);\n        url_fseek(pb, 4, SEEK_SET);\n        put_le32(pb, file_size);\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n        put_le16(pb, video_enc->frame_number);\n    }\n    av_free(swf);\n    return 0;\n}","5630":"static int init_directories(BDRVVVFATState* s,\n                            const char *dirname, int heads, int secs,\n                            Error **errp)\n{\n    bootsector_t* bootsector;\n    mapping_t* mapping;\n    unsigned int i;\n    unsigned int cluster;\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n    s->cluster_size=s->sectors_per_cluster*0x200;\n    s->cluster_buffer=g_malloc(s->cluster_size);\n    \n    i = 1+s->sectors_per_cluster*0x200*8\/s->fat_type;\n    s->sectors_per_fat=(s->sector_count+i)\/i; \n    s->offset_to_fat = s->offset_to_bootsector + 1;\n    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;\n    array_init(&(s->mapping),sizeof(mapping_t));\n    array_init(&(s->directory),sizeof(direntry_t));\n    \n    {\n        direntry_t* entry=array_get_next(&(s->directory));\n        entry->attributes=0x28; \n        memcpy(entry->name, s->volume_label, sizeof(entry->name));\n    }\n    \n    init_fat(s);\n    s->cluster_count=sector2cluster(s, s->sector_count);\n    mapping = array_get_next(&(s->mapping));\n    mapping->begin = 0;\n    mapping->dir_index = 0;\n    mapping->info.dir.parent_mapping_index = -1;\n    mapping->first_mapping_index = -1;\n    mapping->path = g_strdup(dirname);\n    i = strlen(mapping->path);\n    if (i > 0 && mapping->path[i - 1] == '\/')\n        mapping->path[i - 1] = '\\0';\n    mapping->mode = MODE_DIRECTORY;\n    mapping->read_only = 0;\n    s->path = mapping->path;\n    for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n        \n        \n        int fix_fat = (i != 0);\n        mapping = array_get(&(s->mapping), i);\n        if (mapping->mode & MODE_DIRECTORY) {\n            mapping->begin = cluster;\n            if(read_directory(s, i)) {\n                error_setg(errp, \"Could not read directory %s\",\n                           mapping->path);\n                return -1;\n            }\n            mapping = array_get(&(s->mapping), i);\n        } else {\n            assert(mapping->mode == MODE_UNDEFINED);\n            mapping->mode=MODE_NORMAL;\n            mapping->begin = cluster;\n            if (mapping->end > 0) {\n                direntry_t* direntry = array_get(&(s->directory),\n                        mapping->dir_index);\n                mapping->end = cluster + 1 + (mapping->end-1)\/s->cluster_size;\n                set_begin_of_direntry(direntry, mapping->begin);\n            } else {\n                mapping->end = cluster + 1;\n                fix_fat = 0;\n            }\n        }\n        assert(mapping->begin < mapping->end);\n        \n        cluster = mapping->end;\n        if(cluster > s->cluster_count) {\n            error_setg(errp,\n                       \"Directory does not fit in FAT%d (capacity %.2f MB)\",\n                       s->fat_type, s->sector_count \/ 2000.0);\n            return -1;\n        }\n        \n        if (fix_fat) {\n            int j;\n            for(j = mapping->begin; j < mapping->end - 1; j++)\n                fat_set(s, j, j+1);\n            fat_set(s, mapping->end - 1, s->max_fat_value);\n        }\n    }\n    mapping = array_get(&(s->mapping), 0);\n    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;\n    s->last_cluster_of_root_directory = mapping->end;\n    \n    fat_set(s,0,s->max_fat_value);\n    fat_set(s,1,s->max_fat_value);\n    s->current_mapping = NULL;\n    bootsector = (bootsector_t *)(s->first_sectors\n                                  + s->offset_to_bootsector * 0x200);\n    bootsector->jump[0]=0xeb;\n    bootsector->jump[1]=0x3e;\n    bootsector->jump[2]=0x90;\n    memcpy(bootsector->name,\"QEMU    \",8);\n    bootsector->sector_size=cpu_to_le16(0x200);\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n    bootsector->reserved_sectors=cpu_to_le16(1);\n    bootsector->number_of_fats=0x2; \n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n    \n    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);\n    s->fat.pointer[0] = bootsector->media_type;\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n    bootsector->sectors_per_track = cpu_to_le16(secs);\n    bootsector->number_of_heads = cpu_to_le16(heads);\n    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n    \n    \n    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;\n    bootsector->u.fat16.signature=0x29;\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n    memcpy(bootsector->u.fat16.volume_label, s->volume_label,\n           sizeof(bootsector->u.fat16.volume_label));\n    memcpy(bootsector->u.fat16.fat_type,\n           s->fat_type == 12 ? \"FAT12   \" : \"FAT16   \", 8);\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n    return 0;\n}","22801":"DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n{\n    const char *buf;\n    const char *file = NULL;\n    const char *serial;\n    const char *mediastr = \"\";\n    BlockInterfaceType type;\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n    int bus_id, unit_id;\n    int cyls, heads, secs, translation;\n    BlockDriver *drv = NULL;\n    int max_devs;\n    int index;\n    int ro = 0;\n    int bdrv_flags = 0;\n    int on_read_error, on_write_error;\n    const char *devaddr;\n    DriveInfo *dinfo;\n    BlockIOLimit io_limits;\n    int snapshot = 0;\n    bool copy_on_read;\n    int ret;\n    Error *error = NULL;\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n    media = MEDIA_DISK;\n    \n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n    file = qemu_opt_get(opts, \"file\");\n    serial = qemu_opt_get(opts, \"serial\");\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n            ;\n        if (type == IF_COUNT) {\n            error_report(\"unsupported bus type '%s'\", buf);\n            return NULL;\n\t}\n    } else {\n        type = block_default_type;\n    }\n    max_devs = if_max_devs[type];\n    if (cyls || heads || secs) {\n        if (cyls < 1) {\n            error_report(\"invalid physical cyls number\");\n\t    return NULL;\n\t}\n        if (heads < 1) {\n            error_report(\"invalid physical heads number\");\n\t    return NULL;\n\t}\n        if (secs < 1) {\n            error_report(\"invalid physical secs number\");\n\t    return NULL;\n\t}\n    }\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n        if (!cyls) {\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n                         buf);\n            return NULL;\n        }\n        if (!strcmp(buf, \"none\"))\n            translation = BIOS_ATA_TRANSLATION_NONE;\n        else if (!strcmp(buf, \"lba\"))\n            translation = BIOS_ATA_TRANSLATION_LBA;\n        else if (!strcmp(buf, \"auto\"))\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\telse {\n            error_report(\"'%s' invalid translation type\", buf);\n\t    return NULL;\n\t}\n    }\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n        if (!strcmp(buf, \"disk\")) {\n\t    media = MEDIA_DISK;\n\t} else if (!strcmp(buf, \"cdrom\")) {\n            if (cyls || secs || heads) {\n                error_report(\"CHS can't be set with media=%s\", buf);\n\t        return NULL;\n            }\n\t    media = MEDIA_CDROM;\n\t} else {\n\t    error_report(\"'%s' invalid media\", buf);\n\t    return NULL;\n\t}\n    }\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n            error_report(\"invalid discard option\");\n            return NULL;\n        }\n    }\n    bdrv_flags |= BDRV_O_CACHE_WB;\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n            error_report(\"invalid cache option\");\n            return NULL;\n        }\n    }\n#ifdef CONFIG_LINUX_AIO\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n        if (!strcmp(buf, \"native\")) {\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n        } else if (!strcmp(buf, \"threads\")) {\n            \n        } else {\n           error_report(\"invalid aio option\");\n           return NULL;\n        }\n    }\n#endif\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n        if (is_help_option(buf)) {\n            error_printf(\"Supported formats:\");\n            bdrv_iterate_format(bdrv_format_print, NULL);\n            error_printf(\"\\n\");\n            return NULL;\n        }\n        drv = bdrv_find_whitelisted_format(buf);\n        if (!drv) {\n            error_report(\"'%s' invalid format\", buf);\n            return NULL;\n        }\n    }\n    \n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n                           qemu_opt_get_number(opts, \"bps\", 0);\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n                           qemu_opt_get_number(opts, \"iops\", 0);\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n    if (!do_check_io_limits(&io_limits, &error)) {\n        error_report(\"%s\", error_get_pretty(error));\n        error_free(error);\n        return NULL;\n    }\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n                \"ignored. Future versions will reject this parameter. Please \"\n                \"update your scripts.\\n\");\n    }\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n            error_report(\"werror is not supported by this bus type\");\n            return NULL;\n        }\n        on_write_error = parse_block_error_action(buf, 0);\n        if (on_write_error < 0) {\n            return NULL;\n        }\n    }\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n            error_report(\"rerror is not supported by this bus type\");\n            return NULL;\n        }\n        on_read_error = parse_block_error_action(buf, 1);\n        if (on_read_error < 0) {\n            return NULL;\n        }\n    }\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n        if (type != IF_VIRTIO) {\n            error_report(\"addr is not supported by this bus type\");\n            return NULL;\n        }\n    }\n    \n    if (index != -1) {\n        if (bus_id != 0 || unit_id != -1) {\n            error_report(\"index cannot be used with bus and unit\");\n            return NULL;\n        }\n        bus_id = drive_index_to_bus_id(type, index);\n        unit_id = drive_index_to_unit_id(type, index);\n    }\n    \n    if (unit_id == -1) {\n       unit_id = 0;\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n           unit_id++;\n           if (max_devs && unit_id >= max_devs) {\n               unit_id -= max_devs;\n               bus_id++;\n           }\n       }\n    }\n    \n    if (max_devs && unit_id >= max_devs) {\n        error_report(\"unit %d too big (max is %d)\",\n                     unit_id, max_devs - 1);\n        return NULL;\n    }\n    \n    if (drive_get(type, bus_id, unit_id) != NULL) {\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n                     bus_id, unit_id, index);\n        return NULL;\n    }\n    \n    dinfo = g_malloc0(sizeof(*dinfo));\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n        dinfo->id = g_strdup(buf);\n    } else {\n        \n        dinfo->id = g_malloc0(32);\n        if (type == IF_IDE || type == IF_SCSI)\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n        if (max_devs)\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n                     if_name[type], bus_id, mediastr, unit_id);\n        else\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n                     if_name[type], mediastr, unit_id);\n    }\n    dinfo->bdrv = bdrv_new(dinfo->id);\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n    dinfo->bdrv->read_only = ro;\n    dinfo->devaddr = devaddr;\n    dinfo->type = type;\n    dinfo->bus = bus_id;\n    dinfo->unit = unit_id;\n    dinfo->cyls = cyls;\n    dinfo->heads = heads;\n    dinfo->secs = secs;\n    dinfo->trans = translation;\n    dinfo->opts = opts;\n    dinfo->refcount = 1;\n    dinfo->serial = serial;\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n    \n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n    switch(type) {\n    case IF_IDE:\n    case IF_SCSI:\n    case IF_XEN:\n    case IF_NONE:\n        dinfo->media_cd = media == MEDIA_CDROM;\n        break;\n    case IF_SD:\n    case IF_FLOPPY:\n    case IF_PFLASH:\n    case IF_MTD:\n        break;\n    case IF_VIRTIO:\n        \n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n        if (arch_type == QEMU_ARCH_S390X) {\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n        } else {\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n        }\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n        if (devaddr)\n            qemu_opt_set(opts, \"addr\", devaddr);\n        break;\n    default:\n        abort();\n    }\n    if (!file || !*file) {\n        return dinfo;\n    }\n    if (snapshot) {\n        \n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n    }\n    if (copy_on_read) {\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n    }\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n        bdrv_flags |= BDRV_O_INCOMING;\n    }\n    if (media == MEDIA_CDROM) {\n        \n        ro = 1;\n    } else if (ro == 1) {\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n            type != IF_NONE && type != IF_PFLASH) {\n            error_report(\"readonly not supported by this bus type\");\n            goto err;\n        }\n    }\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n    if (ro && copy_on_read) {\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n    }\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n    if (ret < 0) {\n        if (ret == -EMEDIUMTYPE) {\n            error_report(\"could not open disk image %s: not in %s format\",\n                         file, drv->format_name);\n        } else {\n            error_report(\"could not open disk image %s: %s\",\n                         file, strerror(-ret));\n        }\n        goto err;\n    }\n    if (bdrv_key_required(dinfo->bdrv))\n        autostart = 0;\n    return dinfo;\nerr:\n    bdrv_delete(dinfo->bdrv);\n    g_free(dinfo->id);\n    QTAILQ_REMOVE(&drives, dinfo, next);\n    g_free(dinfo);\n    return NULL;\n}"}}